/*
 * (C) 2003-2018 - ntop 
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#define _GNU_SOURCE
#include <cuda.h>
#include <signal.h>
#include <sched.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>
#include <sys/mman.h>
#include <errno.h>
#include <sys/time.h>
#include <time.h>
#include <pthread.h>
#include <sched.h>
#include <stdio.h>
#include <stdint.h>

#include "pfring.h"
#include "pfring_zc.h"

#include "zutils.c"

#define ALARM_SLEEP             1
#define MAX_CARD_SLOTS      32768

//c++ include
#include <iostream>
#include <cstdlib>
#include <string>
#include <vector>
#include <fstream>
#include <sstream>
#include <algorithm>
#include <bitset>
#include <cmath>
#include <iomanip>

using namespace std;

const uint64_t m1  = 0x5555555555555555; //binary: 0101...
const uint64_t m2  = 0x3333333333333333; //binary: 00110011..
const uint64_t m4  = 0x0f0f0f0f0f0f0f0f; //binary:  4 zeros,  4 ones ...
const uint64_t m8  = 0x00ff00ff00ff00ff; //binary:  8 zeros,  8 ones ...
const uint64_t m16 = 0x0000ffff0000ffff; //binary: 16 zeros, 16 ones ...
const uint64_t m32 = 0x00000000ffffffff; //binary: 32 zeros, 32 ones
const uint64_t hff = 0xffffffffffffffff; //binary: all ones
const uint64_t h01 = 0x0101010101010101; //the sum of 256 to the power of 0,1,2,3...

struct timeval startCPU7;
struct timeval endCPU7;
unsigned long diffCPU7=0;

struct timeval startGPU;
struct timeval endGPU;
unsigned long diffGPU=0;

struct timeval startCPU;
struct timeval endCPU;
unsigned long diffCPU=0;

struct timeval startCUDA;
struct timeval endCUDA;
unsigned long diffCUDA=0;


inline int popcount_3(uint64_t x)
{
    x -= (x >> 1) & m1;             //put count of each 2 bits into those 2 bits
    x = (x & m2) + ((x >> 2) & m2); //put count of each 4 bits into those 4 bits 
    x = (x + (x >> 4)) & m4;        //put count of each 8 bits into those 8 bits 
    return (x * h01)>>56;  //returns left 8 bits of x + (x<<8) + (x<<16) + (x<<24) + ... 
}

inline unsigned long long int BitArrayToInt(bool arr[], int count1, int count2)
{
    unsigned long long int ret = 0;
    unsigned long long int tmp;
    for (int i = count1; i < count2; i++) {
        tmp = arr[i];
        ret |= tmp << (count2 - i - 1);
    }
    return ret;
}

inline int BitCount ( unsigned char arr[], int count1, int count2)
{
	int ret = 0;
	for(int i=count1/8;i<count2/8;i++)
	{
		bitset<8> a(arr[i]);
		ret += a.count();
	}
	bitset<8> b(arr[count2/8] & ( 0xff << (8-(count2 & 0x07))));
	ret += b.count();

	return ret;
}

/*unsigned long long int BitArrayToInt(bool arr[], int count1, int count2)
{
	unsigned long long int ret = 0;
	int tmp;
	for(int i = count1; i < count2; i++)
	{
		if(arr[i]==true)
		{
			ret += pow(2, count2-i);
			//cout << ret << endl;
		}
	}
	return ret;
}*/

//cuda
cudaError_t r;

//include mwm
#define DEBUG_AC
#include "mwm.c"
#include "acsmx.c"
#define err printf("file:%s->line(%d):%d\n", __FILE__, __LINE__, cudaGetErrorString(r));

//defined load file
#define T1c_FILE_PATH "DB/T1_char"
//#define T1b_FILE_PATH "DB/T1_table_s"
#define T1b_FILE_PATH "DB/T1_check"
#define T1_FILE_PATH "DB/T1_table_sc"
#define BT_FILE_PATH "DB/BT_table_s"
#define T2_FILE_PATH "DB/T2_s"
#define T2b_FILE_PATH "DB/T2_bit"
#define T2c_FILE_PATH "DB/T2_char"

#define PAT_FILE_PATH "DB/patNumdata"
#define PATTERN_FILE_PATH "DB/patdata"
#define IF_DROP_FILE_PATH "if_drop"
//thread and semaphore
#include <csignal>
#include <semaphore.h>
sem_t os_sem;
sem_t *sem_shm;

int num_threads = 1;
int cluster_id = -1;

//correctness

//defined about GPU
unsigned char *T1, *BT, *T2;
unsigned char *T2b;
unsigned char *T1b;
unsigned char *T1c;
unsigned char *T2c;
u_char* T2ptr[256*256];
static unsigned short *H1;
unsigned int t1size=0, btsize=0, t2size=0, win_size=0, ingpubuf_pktnum=1000, Output_table_size=0, pcapfile_pktnum=0,HMA_mode=false, t2bsize=0, t1bsize=0, t1csize=0, t2csize=0;
unsigned short *gFST1D, *gfailure_table, *gCST1D,*gCST_CDF_size;
short *gfinal_state_table;
bool test_state=false, justgpu = false, justprecpu=false;

unsigned int cap_pkt=0, precount_total=0, pat1or2count_total=0;
fstream outThroughput, fcap, all_test,gpuoutput;
fstream outputyo;
fstream outputgpu;
//global
int two_NIC = 0;
int match_mode = 0;
unsigned int payloadlen = 1458;
unsigned int rec_pkt_size = 1500;
unsigned long long int CountNumofPacketToGpuFun1 = 0;
unsigned long long int CountNumofPacketToGpuFun2 = 0;
int *counterGpuSnort;
int *d_counterGpuSnort;
int counterGPUHit = 0;

//global memory to gpu
int buffer_size ;//=blocksNumper*threadsperBlock;
int blocksNumper;// =32;//16
int threadsperBlock ;//= 256;//512
int bytes;// = sizeof(u_char)*buffer_size*1458;
unsigned long long int temp_test[2] ={0,0};
unsigned long long int kernel_sum =0 ;
int *d_nfound_GPU1,*d_nfound_GPU2;
bool *d_Tablehits1,*d_Tablehits2;
bool *Tablehits1,*Tablehits2;
int *nfound_GPU1,*nfound_GPU2;
u_char* d_fullTable;
u_char* fullTable;
u_char* T1pid;
texture <u_char,1,cudaReadModeElementType> texFulltable;
texture <u_char,1,cudaReadModeElementType> texacsm;

u_char* first_buffer;
u_char* second_buffer;
u_char* __restrict__ Central_memory;
u_char* __restrict__ Central_memory_tail; // = Central_memory;

static unsigned* T1pidTemp;
static unsigned* T1pidInt;

unsigned lastdrops=0,rec_drop_total=0; //2019/1/9 drop

u_char* d_Central_memory;

static u_char bitmasks[8];

//ac
ACSM_STRUCT * acsm;

//mwm
MWM_STRUCT *ps;
pthread_t thread4countT2[2];
vector <bool> T1_1bit;
bitset <256*256> T1_bitset;
static bool *  T1_bool;
unsigned char T1_char[256*256/8];
unsigned char *d_T1_char;
unsigned char T2_char[256*256/8];
unsigned char *d_T2_char;
bool T1b_bool[256*256];
bool T2_bool[256*256];
bool * T1_char1;
bool * T1_char2;

#ifdef _test
char* patArray[2000];
#endif
int stat_mwm;

//string to int, three char to one int
int StrToInt(string str)
{
	int num=0;
	stringstream tmpstrtonum;
	tmpstrtonum << str[0] << str[1] << str[2];
	tmpstrtonum >> num;
	tmpstrtonum.clear();
	return num;
}

//rule of stable_sort, large to small
bool sortRule(const string& s1, const string& s2)
{
	return s1.size() > s2.size();
}

int MatchFound (void* id, int index, void *data)
{
	//printf("%s\n",id);
	return 0;
}
__device__ void MatchFound_AC (void* id)
{
	//printf("1");
	printf ("%s\n",(char *)id);
	//return 0;
}


unsigned long GetFileLength (FILE *filename)
{
	unsigned long pos = ftell(filename);
	unsigned long len = 0;
	fseek (filename, 0 ,SEEK_END);
	len = ftell (filename);
	fseek (filename,pos,SEEK_SET);
	return len;

}

/////////////////////////pop
//#include "popcnt.cpp"
inline int popcnt_naive(unsigned *buf , int n){
	int cnt =0 ;
	unsigned v;
	do {
		v=*buf;
		while(v){
			cnt += v&1;
			v>>=1;
		}
		buf++;
	}while(--n);
	return cnt;
}

/////////20190606 for check T1_char
inline bool CheckT1(int pos){
	unsigned char idx = T1_char[pos >> 3]; // pos/8
	//string str = bitset<8>(T1_char[ pos >> 3 ]).to_string();
	int check = pos & 0x07;
	if( idx & ( 0x01 << (7-check) ) )
	{
		return true;
	}else
	{
		return false;
	}
}

////////20190718 for check T2_char
inline bool CheckT2(int pos){
	unsigned char idx = T2_char[pos >> 3]; // pos/8
	int check = pos & 0x07;
	if( idx & (0x01 << (7-check) ))
	{
		return true;
	}else
	{
		return false;
	}


}

inline static size_t popcnt(uint8_t v){
	size_t rt;
#if INTRIN_WORDSIZE>=64
	printf("if \n\n");
	rt = popcnt((uint64_t)v);
#else
	printf("else \n\n");
	rt = popcnt((uint32_t)v);
#endif
	return rt;
}


static struct timeval startTime;
u_int8_t bidirectional = 0, wait_for_packet = 1, flush_packet = 0, do_shutdown = 0, verbose = 0;

pfring_zc_cluster *zc;

struct dir_info {
  u_int64_t __padding 
  __attribute__((__aligned__(64)));

  pfring_zc_queue *inzq, *outzq;
  pfring_zc_pkt_buff *tmpbuff;

  u_int64_t numPkts;
  u_int64_t numBytes;
  
  char *in_dev;
  char *out_dev;

  int bind_core;
  pthread_t thread
  __attribute__((__aligned__(64)));
};
struct dir_info dir[32]; //dir[2]

/* ******************************** */

void print_stats() {
	struct timeval endTime;
	double deltaMillisec[num_threads];
	static u_int8_t print_all;
	/*static u_int64_t lastPkts = 0;
	static u_int64_t lastBytes = 0;
	static u_int64_t lastDrops = 0;*/
	unsigned long long int lastPkts[num_threads];
	unsigned long long int lastBytes[num_threads];
	unsigned long long int lastDrops[num_threads];

	double diff[num_threads], dropsDiff[num_threads], bytesDiff[num_threads];
	static struct timeval lastTime;
	//char buf1[64], buf2[64], buf3[64];
	char buf1[num_threads][64]={0}, buf2[num_threads][64]={0}, buf3[num_threads][64]={0};
	unsigned long long nBytes = 0, nPkts = 0/*, nDrops = 0*/;
	unsigned int drop_sep[num_threads]={0};
	unsigned int nowdrops= 0; //2019/1/9 drop
	pfring_zc_stat stats;
	int i;
	
	if(startTime.tv_sec == 0) {
		gettimeofday(&startTime, NULL);
		print_all = 0;
	} else
	{
		print_all = 1;
	}
	
	gettimeofday(&endTime, NULL);
	for(i=0;i<num_threads;i++)
	{
		deltaMillisec[i] = delta_time(&endTime, &startTime);
	}

  /*for (i = 0; i < 1 + bidirectional; i++) {
    nBytes += dir[i].numBytes;
    nPkts += dir[i].numPkts;
    if (pfring_zc_stats(dir[i].inzq, &stats) == 0)
      nDrops += stats.drop;
  }*/
	/*for (i = 0; i<num_threads;i++)
	{
		nBytes += dir[i].numBytes;
		nPkts += dir[i].numPkts;
		if (pfring_zc_stats(dir[i].inzq, &stats) == 0)
		{
			nDrops += stats.drop;
		}
	}*/

  /*fprintf(stderr, "=========================\n"
	  "Absolute Stats: %s pkts (%s drops) - %s bytes\n", 
	  pfring_format_numbers((double)nPkts, buf1, sizeof(buf1), 0),
	  pfring_format_numbers((double)nDrops, buf3, sizeof(buf3), 0),
	  pfring_format_numbers((double)nBytes, buf2, sizeof(buf2), 0));

  if(print_all && (lastTime.tv_sec > 0)) {
    char buf[256];

    deltaMillisec = delta_time(&endTime, &lastTime);
    diff = nPkts-lastPkts;
    dropsDiff = nDrops-lastDrops;
    bytesDiff = nBytes - lastBytes;
    bytesDiff /= (1000*1000*1000)/8;

    snprintf(buf, sizeof(buf),
	     "Actual Stats: %s pps (%s drops) - %s Gbps",
	     pfring_format_numbers(((double)diff/(double)(deltaMillisec/1000)),  buf2, sizeof(buf2), 1),
	     pfring_format_numbers(((double)dropsDiff/(double)(deltaMillisec/1000)),  buf1, sizeof(buf1), 1),
	     pfring_format_numbers(((double)bytesDiff/(double)(deltaMillisec/1000)),  buf3, sizeof(buf3), 1));
    fprintf(stderr, "%s\n", buf);
  }
    
  fprintf(stderr, "=========================\n\n");*/
  	cout<<"=========="<<endl;
	for(i=0;i<num_threads;i++)
	{
		if (pfring_zc_stats(dir[i].inzq, &stats) == 0)
		{
			//cout<<"recv: "<<stats.recv<<" sent: "<<stats.sent<<" drop: "<<stats.drop<<endl;
			drop_sep[i] = (unsigned int)stats.drop;
			fprintf(stderr, "Thread: %d Now: %s pkts (%s drops)  ", //- %s bytes\n
				i,
				pfring_format_numbers((double)dir[i].numPkts, buf1[i], sizeof(buf1[i]), 0),
				pfring_format_numbers((double)drop_sep[i], buf3[i], sizeof(buf3[i]), 0)
				/*pfring_format_numbers((double)dir[i].numBytes, buf2, sizeof(buf2), 0)*/);

			if(print_all && (lastTime.tv_sec > 0)) 
			{
				char buf[256];

				deltaMillisec[i] = delta_time(&endTime, &lastTime);
				diff[i] = dir[i].numPkts-lastPkts[i];
				dropsDiff[i] = drop_sep[i]-lastDrops[i];
				bytesDiff[i] = dir[i].numBytes - lastBytes[i];
				bytesDiff[i] /= (1000*1000*1000)/8;
				cout<<"test lastBytes: "<<lastBytes[i]<<" dir[i].numBytes: "<<dir[i].numBytes<<" ";

				snprintf(buf, sizeof(buf),
					"Throughput: %s Gbps", //ALL: %s pps (%s drops) - %s Gbps
					/*pfring_format_numbers(((double)diff[i]/(double)(deltaMillisec/1000)),  buf2[i], sizeof(buf2[i]), 1),
					pfring_format_numbers(((double)dropsDiff[i]/(double)(deltaMillisec/1000)),  buf1[i], sizeof(buf1[i]), 1),*/
					pfring_format_numbers(((double)bytesDiff[i]),  buf3[i], sizeof(buf3[i]), 1));
				fprintf(stderr, "%s", buf);
			}
			
			//fprintf(stderr, "=========================\n\n");
			cout<<endl;
			
			lastPkts[i] = dir[i].numPkts;
			lastDrops[i] = drop_sep[i];
			lastBytes[i] = dir[i].numBytes;

			lastTime.tv_sec = endTime.tv_sec, lastTime.tv_usec = endTime.tv_usec;
		}
	}
	double throughput=0;
	for(int i=0;i<num_threads;i++)
	{
			throughput += bytesDiff[i];
			nowdrops += drop_sep[i]; //20191/9 drop
	}
	rec_drop_total = nowdrops - lastdrops; //20191/9 drop
	lastdrops = nowdrops; //20191/9 drop
	cout<<"if_drop  = "<<rec_drop_total<<endl;
	cout<<"ALL Throughput = "<<throughput<<endl;

	//2019/1/14 if_drop from sigproc to printstate
	outThroughput.open( IF_DROP_FILE_PATH ,ios::out | ios::ate);
	outThroughput << rec_drop_total;
	outThroughput.close();

	cout << "rec_drop_total: " << rec_drop_total << endl;
	
	

}

/* ******************************** */

void sigproc(int sig) {
  static int called = 0;
  fprintf(stderr, "Leaving...\n");
  if(called) return; else called = 1;

  do_shutdown = 1;

  //print_stats();
  
  /*pfring_zc_queue_breakloop(dir[0].inzq);
  if (bidirectional) pfring_zc_queue_breakloop(dir[1].inzq);*/
	for(int i=0;i<num_threads;i++)
	{
		pfring_zc_queue_breakloop(dir[i].inzq);
	}
	
	/*outThroughput.open( IF_DROP_FILE_PATH ,ios::out | ios::ate);
	outThroughput << rec_drop_total;
	outThroughput.close();

	cout << "rec_drop_total: " << rec_drop_total << endl;*/
}

/* *************************************** */

void printHelp(void) {
	printf("compile success!!!\n");
  printf("zbounce - (C) 2014-2018 ntop.org\n");
  printf("Using PFRING_ZC v.%s\n", pfring_zc_version());
  printf("A packet forwarder application between interfaces.\n\n");
  printf("Usage:  zbounce -i <device> -o <device> -c <cluster id> [-b]\n"
	 "                [-h] [-g <core id>] [-f] [-v] [-a]\n\n");
  printf("-h              Print this help\n");
  printf("-i <device>     Ingress device name\n");
  printf("-o <device>     Egress device name\n");
  printf("-c <cluster id> cluster id\n");
  printf("-b              Bridge mode (forward in both directions)\n");
  printf("-g <core id>    Bind this app to a core (with -b use <core id>:<core id>)\n");
  printf("-a              Active packet wait\n");
  printf("-f              Flush packets immediately\n");
  printf("-v              Verbose\n");
  printf("-e              match mode\n");
  printf("-n              num of threads\n");
  printf("-N              Two NIC control\n");
  printf("-s              BlocksNumper\n");
  printf("-t              threadsperBlock\n");
  exit(-1);
}

/* *************************************** */
//CUDA kernel function

__global__ void snort_ac(u_char * Tx, ACSM_STRUCT * acsm,int len, int *nfound_GPU,bool *Tablehits, u_char * fullTable, unsigned char *T1_char, unsigned char *T2_char)
//__global__ void snort_ac(u_char * Tx, ACSM_STRUCT * acsm,int len, int *nfound_GPU,bool *Tablehits, u_char * fullTable)
//__global__ void snort_ac(u_char * Tx, ACSM_STRUCT * acsm,int len, int *nfound_GPU,bool *Tablehits, int *counter,void (*Match) (void *id))//, u_char * fullTable)
{
	printf("T2: %d\n",*(T2_char+1));
	//printf("\nIN GPU \n");
	int gid= blockIdx.x*blockDim.x+threadIdx.x;
	//int gid= blockIdx.x*threadIdx.x;
	int tid= threadIdx.x;
	int state=0;
	int mlist_counter=0;
	__shared__	ACSM_PATTERN * mlist;
	//ACSM_PATTERN * mlist;
	unsigned char *Tend;
	__shared__	ACSM_STATETABLE * StateTable;
	//ACSM_STATETABLE * StateTable;
	StateTable= acsm->acsmStateTable;
	unsigned char *T;
	T=Tx+gid*len+3;
	Tend = T + len -3;
	//printf("%d\n",gid);
	//printf("%d: %d, %d, %d\n", gid,*T,*(T+1),*(T+2));  //work
	//printf("%d\n",(int)Tend-(int)T);
	//nfound_GPU[gid]++;
	unsigned char T1[2560];
	T1[gid] = T1_char[gid];
	//printf("T1_CHAR: %d, %d\n",*T1,T1[0]);
	__syncthreads();

	for (state = 0; T < Tend-2 ; T++)
	{	
		//	if( tex1Dfetch( texFulltable,(( *T << 7 |  *(T+1) )<< 5 ) | *(T+2) >> 3) & (128 >> (*(T+2)%8 )) )
		/*if( tex1Dfetch( texFulltable,(( *T *256 +  *(T+1) )*32 ) + *(T+2) /8) & (128 >> (*(T+2)%8 )) )
		{
			Tablehits[gid]=1;
		}*/
		/*if( !tex1Dfetch( texFulltable,(( *T *256 +  *(T+1) )*32 ) + *(T+2) /8) & (128 >> (*(T+2)%8 )) )
                {
                	printf("%d, %d, %d\n",*T,*(T+1),*(T+2));
                }*/

		// into T2 times counting
		state = StateTable[state].NextState[*T];
		
		if( StateTable[state].MatchList != NULL )
		{
			for( mlist=StateTable[state].MatchList; mlist!=NULL;
					mlist=mlist->next )
			{
				nfound_GPU[gid]=nfound_GPU[gid]+1;
				////char		nfound_GPU[id*4+mlist_counter]= mlist->iid;
			}
		}

	}

}
//GGG
__global__ void partcial_snort_ac(u_char * Tx, ACSM_STRUCT * acsm,int len, int *nfound_GPU,bool *Tablehits)//, u_char * fullTable)
{
	//printf("\nIN GPU \n");
	int gid= blockIdx.x*blockDim.x+threadIdx.x;
	//int id= blockIdx.x*blockDim.x;
	int tid= threadIdx.x;
	int state=0;
	int mlist_counter=0;
	__shared__	ACSM_PATTERN * mlist;
	unsigned char *Tend;
	__shared__	ACSM_STATETABLE * StateTable;
	StateTable= acsm->acsmStateTable;
	unsigned char *T;
	
	//printf("%d\n",id);
	
	T=Tx+gid*len;
	Tend = T + len;
	//int base = 	(*(T+1)<<8)+(*T);

	int base=0;
	((unsigned char*)(&base))[0] = *T;
	((unsigned char*)(&base))[1] = *(T+1);
	/*for(int i=0;i<4;i++)
	{
		printf("%02X",((unsigned char*)(&base)[i]));
	}*/
	//memcpy(&base,T,2);
	//int base = 0;
	//printf("%d\n",base);
	//printf("%d~%d\n",(*T),*(T+1));
	//printf("gpu %d  \n",*T+(*(T+1)<<8));
	T=T+base+3;
	//T = T + 0x10 + (((*T)<<8)+(*(T+1)));
	//printf("%d,%d\n",base,(int)Tend-(int)T);
	for (state = 0; T < Tend ; T++)
	{	
		//	if( tex1Dfetch( texFulltable,(( *T << 7 |  *(T+1) )<< 5 ) | *(T+2) >> 3) & (128 >> (*(T+2)%8 )) )
#ifdef _GPUpre	
		if( tex1Dfetch( texFulltable,(( *T *256 +  *(T+1) )*32 ) + *(T+2) /8) & (128 >> (*(T+2)%8 )) )
		{
			Tablehits[id]	=1;
		}
		// into T2 times counting
#endif
		state = StateTable[state].NextState[*T];


		if( StateTable[state].MatchList != NULL )
		{

			for( mlist=StateTable[state].MatchList; mlist!=NULL;
					mlist=mlist->next )
			{

				nfound_GPU[gid]=nfound_GPU[gid]+1;
				////char		nfound_GPU[id*4+mlist_counter]= mlist->iid;
			}

		}

	}

}

/* *************************************** */

void* GPUKernelFunction_1(void* id){
	//cout << "T1: " << (int)T1_char[0] << endl;
gettimeofday(&startCUDA,NULL);
	//cout<<"In GPUKernelFunction_1"<<endl;
	cudaMemcpy(d_Central_memory,Central_memory,bytes,cudaMemcpyHostToDevice);
	cudaMemcpy(d_T1_char,&T1_char,65536/8,cudaMemcpyHostToDevice);
	cudaMemcpy(d_T2_char,&T2_char,53760/8,cudaMemcpyHostToDevice);
gettimeofday(&startGPU,NULL);
	snort_ac<<<blocksNumper,threadsperBlock>>>(d_Central_memory,acsm,(payloadlen+3),d_nfound_GPU1,d_Tablehits1,d_fullTable,d_T1_char,d_T2_char);	
	//snort_ac<<<blocksNumper,threadsperBlock>>>(d_Central_memory,acsm,(payloadlen+3),d_nfound_GPU1,d_Tablehits1,d_fullTable);	
	//snort_ac<<<blocksNumper,threadsperBlock>>>(d_Central_memory,acsm,payloadlen,d_nfound_GPU1,d_Tablehits1, d_counterGpuSnort, MatchFound_AC);// ,d_fullTable);	
	cudaMemcpy(nfound_GPU1, d_nfound_GPU1,sizeof(int)*(blocksNumper*threadsperBlock), cudaMemcpyDeviceToHost);
	cudaMemcpy(Tablehits1, d_Tablehits1,sizeof(bool)*(blocksNumper*threadsperBlock), cudaMemcpyDeviceToHost);
	
	cudaDeviceSynchronize();
gettimeofday(&endGPU,NULL);
diffGPU += 1000000*(endGPU.tv_sec-startGPU.tv_sec)+endGPU.tv_usec-startGPU.tv_usec;
#ifdef _test
	int temp_max=0;
	for(int i=0;i<blocksNumper*threadsperBlock;i++){
		if(nfound_GPU1[i]!=0){
			if(nfound_GPU1[i]>=temp_max){
				temp_max=nfound_GPU1[i];
			}
			gpuoutput<<nfound_GPU1[i]<<endl;

		}
	}
#endif
	/*
	   temp_test[0] = popcount_lauradoux((unsigned*)Tablehits1,blocksNumper*threadsperBlock/4);
	   kernel_sum+=temp_test[0];
	   temp_test[0]=0;
	*/
	// couting hit times
	CountNumofPacketToGpuFun1++;
	for(int i=0;i<blocksNumper*threadsperBlock;i++)
	{
		//temp_test[0]=temp_test[0]+(nfound_GPU1[i]);
		temp_test[0]=temp_test[0]+(Tablehits1[i]);
	}
	kernel_sum+=temp_test[0];
	temp_test[0]=0;
	//reset memory
	cudaMemset(d_nfound_GPU1,0,sizeof(int)*blocksNumper*threadsperBlock*4);
	memset(nfound_GPU1,0,sizeof(int)*blocksNumper*threadsperBlock*4);
	cudaMemset(d_Tablehits1,0,sizeof(bool)*blocksNumper*threadsperBlock);
	//printf("\n after before kernel1  found_GPU1 = %d  id=%d\n",nfound_GPU1[(intptr_t)id],id);
	//	printf("after kernel1  found_GPU1 = %d \n",nfound_GPU1[0]);
	
gettimeofday(&endCUDA,NULL);
diffCUDA += 1000000*(endCUDA.tv_sec-startCUDA.tv_sec)+endCUDA.tv_usec-startCUDA.tv_usec;
	
	pthread_exit(NULL);
}

void* GPUKernelFunction_2(void* id){
gettimeofday(&startCUDA,NULL);
	//cout<<"In GPUKernelFunction_2"<<endl;
	cudaMemcpy(d_Central_memory+bytes,first_buffer,bytes,cudaMemcpyHostToDevice);
	cudaMemcpy(d_T1_char,&T1_char,65536/8,cudaMemcpyHostToDevice);
	cudaMemcpy(d_T2_char,&T2_char,53760/8,cudaMemcpyHostToDevice);
gettimeofday(&startGPU,NULL);
	snort_ac<<<blocksNumper,threadsperBlock>>>(d_Central_memory+bytes,acsm,(payloadlen+3),d_nfound_GPU2,d_Tablehits2,d_fullTable,T1_char,T2_char);	
	//snort_ac<<<blocksNumper,threadsperBlock>>>(d_Central_memory+bytes,acsm,(payloadlen+3),d_nfound_GPU2,d_Tablehits2,d_fullTable);	
	//snort_ac<<<blocksNumper,threadsperBlock>>>(d_Central_memory+bytes,acsm,payloadlen,d_nfound_GPU2,d_Tablehits2, d_counterGpuSnort,MatchFound_AC);//,d_fullTable);	
	cudaMemcpy(nfound_GPU2,d_nfound_GPU2,sizeof(int)*(blocksNumper*threadsperBlock), cudaMemcpyDeviceToHost);
	cudaMemcpy(Tablehits2, d_Tablehits2,sizeof(bool)*(blocksNumper*threadsperBlock), cudaMemcpyDeviceToHost);
	
	cudaDeviceSynchronize();
gettimeofday(&endGPU,NULL);
diffGPU += 1000000*(endGPU.tv_sec-startGPU.tv_sec)+endGPU.tv_usec-startGPU.tv_usec;
	//counting hit time
	CountNumofPacketToGpuFun2++;
	for(int i=0;i<blocksNumper*threadsperBlock;i++)
	{
		//temp_test[1]=temp_test[1]+(nfound_GPU2[i]);
		temp_test[1]=temp_test[1]+(Tablehits2[i]);
	}
	kernel_sum += temp_test[1];
	temp_test[1]=0;

	/*
	   temp_test[1] =popcount_lauradoux((unsigned*)Tablehits2,blocksNumper*threadsperBlock/4);
	   kernel_sum+=temp_test[1];
	   temp_test[1]=0;
	 */

	//cout<< popcount_lauradoux((unsigned*)Tablehits2,blocksNumper*threadsperBlock/4)<<endl;
#ifdef _test
	int temp_max=0;
	for(int i=0;i<blocksNumper*threadsperBlock;i++)
		if(nfound_GPU2[i]!=0)
		{
			if(nfound_GPU2[i]>=temp_max)	{	
				temp_max=nfound_GPU2[i];
			}

			gpuoutput<<nfound_GPU2[i]<<endl;
		}
#endif

	//reset memory
	cudaMemset(d_nfound_GPU2,0,sizeof(int)*blocksNumper*threadsperBlock);
	cudaMemset(d_Tablehits2,0,sizeof(bool)*blocksNumper*threadsperBlock);
	memset(nfound_GPU2,0,sizeof(int)*blocksNumper*threadsperBlock);
	//printf("\n after kernel2 nfound_GPU2 = %d , id= %d \n",nfound_GPU2[(intptr_t)id],id);
	
gettimeofday(&endCUDA,NULL);
diffCUDA += 1000000*(endCUDA.tv_sec-startCUDA.tv_sec)+endCUDA.tv_usec-startCUDA.tv_usec;

	pthread_exit(NULL);
}

void* GPUKernelFunction_3(void* id){
gettimeofday(&startCUDA,NULL);
	cudaMemcpy(d_Central_memory,Central_memory,bytes,cudaMemcpyHostToDevice);
gettimeofday(&startGPU,NULL);
	partcial_snort_ac<<<blocksNumper,threadsperBlock>>>(d_Central_memory,acsm,(payloadlen+3),d_nfound_GPU1,d_Tablehits1);// ,d_fullTable);	
	cudaMemcpy(nfound_GPU1, d_nfound_GPU1,sizeof(int)*(blocksNumper*threadsperBlock), cudaMemcpyDeviceToHost);
#ifdef GPUpre
	cudaMemcpy(Tablehits1, d_Tablehits1,sizeof(bool)*(blocksNumper*threadsperBlock), cudaMemcpyDeviceToHost);
#endif
	cudaDeviceSynchronize();
gettimeofday(&endGPU,NULL);
diffGPU += 1000000*(endGPU.tv_sec-startGPU.tv_sec)+endGPU.tv_usec-startGPU.tv_usec;
#ifdef _test
	int temp_max=0;
	for(int i=0;i<blocksNumper*threadsperBlock;i++){
		if(nfound_GPU1[i]!=0){
			if(nfound_GPU1[i]>=temp_max){
				temp_max=nfound_GPU1[i];
			}
			gpuoutput<<nfound_GPU1[i]<<endl;

		}
	}
#endif
	/*
	   temp_test[0] = popcount_lauradoux((unsigned*)Tablehits1,blocksNumper*threadsperBlock/4);
	   kernel_sum+=temp_test[0];
	   temp_test[0]=0;
	 */
	// couting hit times
	CountNumofPacketToGpuFun1++;
	for(int i=0;i<blocksNumper*threadsperBlock;i++)
		temp_test[0]=temp_test[0]+(nfound_GPU1[i]);
	kernel_sum+=temp_test[0];
	temp_test[0]=0;
	//reset memory
	cudaMemset(d_nfound_GPU1,0,sizeof(int)*blocksNumper*threadsperBlock*4);
	memset(nfound_GPU1,0,sizeof(int)*blocksNumper*threadsperBlock*4);
	cudaMemset(d_Tablehits1,0,sizeof(bool)*blocksNumper*threadsperBlock);
	//printf("\n after before kernel1  found_GPU1 = %d  id=%d\n",nfound_GPU1[(intptr_t)id],id);
	//	printf("after kernel1  found_GPU1 = %d \n",nfound_GPU1[0]);
	
gettimeofday(&endCUDA,NULL);
diffCUDA += 1000000*(endCUDA.tv_sec-startCUDA.tv_sec)+endCUDA.tv_usec-startCUDA.tv_usec;
	
	pthread_exit(NULL);

}

void* GPUKernelFunction_4(void* id){
gettimeofday(&startCUDA,NULL);
	cudaMemcpy(d_Central_memory+bytes,first_buffer,bytes,cudaMemcpyHostToDevice);
gettimeofday(&startGPU,NULL);
	partcial_snort_ac<<<blocksNumper,threadsperBlock>>>(d_Central_memory+bytes,acsm,(payloadlen+3),d_nfound_GPU2,d_Tablehits2);//,d_fullTable);	
	cudaMemcpy(nfound_GPU2,d_nfound_GPU2,sizeof(int)*(blocksNumper*threadsperBlock), cudaMemcpyDeviceToHost);
#ifdef GPUpre
	cudaMemcpy(Tablehits2, d_Tablehits2,sizeof(bool)*(blocksNumper*threadsperBlock), cudaMemcpyDeviceToHost);
#endif

	cudaDeviceSynchronize();
gettimeofday(&endGPU,NULL);
diffGPU += 1000000*(endGPU.tv_sec-startGPU.tv_sec)+endGPU.tv_usec-startGPU.tv_usec;
	//counting hit time
	CountNumofPacketToGpuFun2++;
	for(int i=0;i<blocksNumper*threadsperBlock;i++)
		temp_test[1]=temp_test[1]+(nfound_GPU2[i]);

	kernel_sum += temp_test[1];
	temp_test[1]=0;

	/*
	   temp_test[1] =popcount_lauradoux((unsigned*)Tablehits2,blocksNumper*threadsperBlock/4);
	   kernel_sum+=temp_test[1];
	   temp_test[1]=0;
	 */

	//cout<< popcount_lauradoux((unsigned*)Tablehits2,blocksNumper*threadsperBlock/4)<<endl;
#ifdef _test
	int temp_max=0;
	for(int i=0;i<blocksNumper*threadsperBlock;i++)
		if(nfound_GPU2[i]!=0)
		{
			//	cout<<"  "<<nfound_GPU1[i]<<"  i= " <<i;
			if(nfound_GPU2[i]>=temp_max)	{	
				temp_max=nfound_GPU2[i];
			}

			gpuoutput<<nfound_GPU2[i]<<endl;
		}
#endif

	//reset memory
	cudaMemset(d_nfound_GPU2,0,sizeof(int)*blocksNumper*threadsperBlock);
	cudaMemset(d_Tablehits2,0,sizeof(bool)*blocksNumper*threadsperBlock);
	memset(nfound_GPU2,0,sizeof(int)*blocksNumper*threadsperBlock);
	//printf("\n after kernel2 nfound_GPU2 = %d , id= %d \n",nfound_GPU2[(intptr_t)id],id);
gettimeofday(&endCUDA,NULL);
diffCUDA += 1000000*(endCUDA.tv_sec-startCUDA.tv_sec)+endCUDA.tv_usec-startCUDA.tv_usec;

	pthread_exit(NULL);

}

void* GPUKernelFunction_8(void* id){
	//cout<<"In GPUKernelFunction_1"<<endl;
	cudaMemcpy(d_Central_memory,Central_memory,bytes,cudaMemcpyHostToDevice);
	//snort_ac<<<blocksNumper,threadsperBlock>>>(d_Central_memory,acsm,payloadlen,d_nfound_GPU1,d_Tablehits1);// ,d_fullTable);	
	//cudaMemcpy(nfound_GPU1, d_nfound_GPU1,sizeof(int)*(blocksNumper*threadsperBlock), cudaMemcpyDeviceToHost);
#ifdef GPUpre
	cudaMemcpy(Tablehits1, d_Tablehits1,sizeof(bool)*(blocksNumper*threadsperBlock), cudaMemcpyDeviceToHost);
#endif
	cudaDeviceSynchronize();
#ifdef _test
	int temp_max=0;
	for(int i=0;i<blocksNumper*threadsperBlock*4;i++){
		if(nfound_GPU1[i]!=0){
			if(nfound_GPU1[i]>=temp_max){
				temp_max=nfound_GPU1[i];
			}
			gpuoutput<<"  "<<nfound_GPU1[i]<<endl;

		}
	}
#endif
	/*
	   temp_test[0] = popcount_lauradoux((unsigned*)Tablehits1,blocksNumper*threadsperBlock/4);
	   kernel_sum+=temp_test[0];
	   temp_test[0]=0;
	 */
	// couting hit times
	for(int i=0;i<blocksNumper*threadsperBlock;i++)
		temp_test[0]=temp_test[0]+(nfound_GPU1[i]);
	//	cout<<"\n buffer1 "<<temp_test[0]<<" \n";
	kernel_sum+=temp_test[0];
	temp_test[0]=0;
	//reset memory
	cudaMemset(d_nfound_GPU1,0,sizeof(int)*blocksNumper*threadsperBlock*4);
	memset(nfound_GPU1,0,sizeof(int)*blocksNumper*threadsperBlock*4);
	cudaMemset(d_Tablehits1,0,sizeof(bool)*blocksNumper*threadsperBlock);
	//printf("\n after before kernel1  found_GPU1 = %d  id=%d\n",nfound_GPU1[(intptr_t)id],id);
	//	printf("after kernel1  found_GPU1 = %d \n",nfound_GPU1[0]);
	pthread_exit(NULL);
}

void* GPUKernelFunction_9(void* id){
	//cout<<"In GPUKernelFunction_2"<<endl;
	cudaMemcpy(d_Central_memory+bytes,first_buffer,bytes,cudaMemcpyHostToDevice);
	//snort_ac<<<blocksNumper,threadsperBlock>>>(d_Central_memory+bytes,acsm,payloadlen,d_nfound_GPU2,d_Tablehits2);//,d_fullTable);	
	//cudaMemcpy(nfound_GPU2,d_nfound_GPU2,sizeof(int)*(blocksNumper*threadsperBlock), cudaMemcpyDeviceToHost);
#ifdef GPUpre
	cudaMemcpy(Tablehits2, d_Tablehits2,sizeof(bool)*(blocksNumper*threadsperBlock), cudaMemcpyDeviceToHost);
#endif

	cudaDeviceSynchronize();
	//counting hit time
	for(int i=0;i<blocksNumper*threadsperBlock;i++)
		temp_test[1]=temp_test[1]+(nfound_GPU2[i]);

	//	cout<<"\n buffer2 "<<temp_test[1]<<" \n";
	kernel_sum += temp_test[1];
	temp_test[1]=0;

	/*
	   temp_test[1] =popcount_lauradoux((unsigned*)Tablehits2,blocksNumper*threadsperBlock/4);
	   kernel_sum+=temp_test[1];
	   temp_test[1]=0;
	 */

	//cout<< popcount_lauradoux((unsigned*)Tablehits2,blocksNumper*threadsperBlock/4)<<endl;
#ifdef _test
	int temp_max=0;
	for(int i=0;i<blocksNumper*threadsperBlock;i++)
		if(nfound_GPU2[i]!=0)
		{
			//	cout<<"  "<<nfound_GPU1[i]<<"  i= " <<i;
			if(nfound_GPU2[i]>=temp_max)	{	
				temp_max=nfound_GPU2[i];
			}

			gpuoutput<<"  "<<nfound_GPU2[i]<<endl;
		}
#endif

	//reset memory
	cudaMemset(d_nfound_GPU2,0,sizeof(int)*blocksNumper*threadsperBlock);
	cudaMemset(d_Tablehits2,0,sizeof(bool)*blocksNumper*threadsperBlock);
	memset(nfound_GPU2,0,sizeof(int)*blocksNumper*threadsperBlock);
	//printf("\n after kernel2 nfound_GPU2 = %d , id= %d \n",nfound_GPU2[(intptr_t)id],id);

	pthread_exit(NULL);
}

/* *************************************** */

//CPU function
void *packet_consumer_thread(void *_i) {
	struct dir_info *i = (struct dir_info *) _i;
	int tx_queue_not_empty = 0;
	u_char* buffer;
	//gpu
	pthread_t thread4gpu[8];
	//time
	struct timeval start;
	struct timeval end;
	unsigned long diff=0;
//#ifdef _test
	//gpuoutput.open("gpuoutput.txt",ios::out|ios::trunc);
//#endif
	//acsm
	int nfound=0;
  
	if (i->bind_core >= 0)
	{
		bind2core(i->bind_core);
	}
	cout << "i am : " << i->bind_core << endl;
  ////////////////////////////////////////
    if(match_mode == 7) //CPU-AC
    {
	  cout<<"In match_mode = 7 CPU-AC"<<endl;
	  int ingpubufcount = 0;

	  while(!do_shutdown) {

		if(pfring_zc_recv_pkt(i->inzq, &i->tmpbuff, wait_for_packet /* 0 */) > 0) {

		  if (unlikely(verbose)) {
	//#if 1  Print 5-tuple and other info
		char strbuf[4096];
			int strlen = sizeof(strbuf);
			int strused = snprintf(strbuf, strlen, "[%s -> %s]", i->in_dev, i->out_dev);
			pfring_print_pkt(&strbuf[strused], strlen - strused, pfring_zc_pkt_buff_data(i->tmpbuff, i->inzq), i->tmpbuff->len, i->tmpbuff->len);
			fputs(strbuf, stdout);
	/*#else // Print hex
		u_char *pkt_data = pfring_zc_pkt_buff_data(i->tmpbuff, i->inzq);
			int j;
			for(j = 0; j < i->tmpbuff->len; j++)
			  printf("%02X ", pkt_data[j]);
			printf("\n");
	#endif*/
		  }

	/*#if 0 // Example of header modification pushing a vlan header
		  {
			struct ethhdr eth;
			u_char *pkt_data = pfring_zc_pkt_buff_data(i->tmpbuff, i->inzq);
			memcpy(&eth, pkt_data, sizeof(eth));
			pkt_data = pfring_zc_pkt_buff_push(i->tmpbuff, i->inzq, sizeof(struct eth_vlan_hdr));
			if (pkt_data != NULL) {
			  struct eth_vlan_hdr vlan;
			  vlan.h_proto = eth.h_proto;
			  vlan.h_vlan_id = htons(10); // VLAN ID
			  eth.h_proto = htons(0x8100); // 802.1q (VLAN)
			  memcpy(pkt_data, &eth, sizeof(eth));
			  memcpy(&pkt_data[sizeof(eth)], &vlan, sizeof(vlan));
			}
		  }
	#endif*/
		  
		  buffer = pfring_zc_pkt_buff_data(i->tmpbuff, i->inzq)+42;


		  //sem_wait(&os_sem);
		  /*for(int i=0;i<1450;i++)
		  {
		 	printf("%x\t",*(buffer+i));
		  }*/
		  /*for(int i=-3;i<2;i++)
		  {
		  	printf("%x\t",*(buffer+i));
		  }
		  cout << endl;
		  sem_post(&os_sem);*/

		  i->numPkts++;
		  i->numBytes += i->tmpbuff->len + 24; /* 8 Preamble + 4 CRC + 12 IFG */
			  
		  errno = 0;
		  while (unlikely(pfring_zc_send_pkt(i->outzq, &i->tmpbuff, flush_packet) < 0 && errno != EMSGSIZE && !do_shutdown)) //send packet
		if (wait_for_packet) usleep(1);

		  //ad matching
		  ingpubufcount++;

		  //sem_wait(&os_sem);
		  //cout << ingpubufcount << ": ";
		
		 // gettimeofday(&startCPU7,NULL);
		  nfound+=acsmSearch(acsm, buffer, payloadlen, MatchFound, 0);
		  //gettimeofday(&endCPU7,NULL);
		  //diffCPU7 += 1000000*(endCPU7.tv_sec-startCPU7.tv_sec)+endCPU7.tv_usec-startCPU7.tv_usec;
		  //cout << endl;
		  //sem_post(&os_sem);
			/*sem_wait(&os_sem);
	  cout << nfound << endl;
			sem_post(&os_sem);
			nfound=0;*/


		  tx_queue_not_empty = 1;
		} else {
		  if (tx_queue_not_empty) {
			pfring_zc_sync_queue(i->outzq, tx_only);
			tx_queue_not_empty = 0;
		  }
		  if (wait_for_packet) 
			usleep(1);
		}
		//cout<<"nfound: "<<nfound<<endl;
	  }
			sem_wait(&os_sem);
			//cout << ingpubufcount << endl;
			//printf("%x\n",*buffer);
			cout << "nfound: " << nfound << endl;
			//cout << "diffCPU: " << diffCPU7 << endl;
			sem_post(&os_sem);

	  if (!flush_packet) //after exit
	  {
		pfring_zc_sync_queue(i->outzq, tx_only);
	  }
	  pfring_zc_sync_queue(i->inzq, rx_only);
	}
  ////////////////////////////////////////
	if(match_mode == 4) //GPU-AC
	{
		cout<<"In match_mode = 4 GPU-AC"<<endl;
		u_char* temp;
		int ingpubufcount = 0;
		while(!do_shutdown) 
		{
			if(pfring_zc_recv_pkt(i->inzq, &i->tmpbuff, wait_for_packet) > 0) 
			{
				if (unlikely(verbose)) 
				{
					char strbuf[4096];
					int strlen = sizeof(strbuf);
					int strused = snprintf(strbuf, strlen, "[%s -> %s]", i->in_dev, i->out_dev);
					pfring_print_pkt(&strbuf[strused], strlen - strused, pfring_zc_pkt_buff_data(i->tmpbuff, i->inzq), i->tmpbuff->len, i->tmpbuff->len);
					fputs(strbuf, stdout);
				}
				buffer = pfring_zc_pkt_buff_data(i->tmpbuff, i->inzq)+42;
				// printf("buffer: %d\n",*buffer);
				ingpubufcount++;
				i->numPkts++;
				i->numBytes += i->tmpbuff->len + 24; /* 8 Preamble + 4 CRC + 12 IFG */
				  
				errno = 0;
				while (unlikely(pfring_zc_send_pkt(i->outzq, &i->tmpbuff, flush_packet) < 0 && errno != EMSGSIZE && !do_shutdown)) //send packet
				if (wait_for_packet)
				{					
					usleep(1);
				}

				tx_queue_not_empty = 1;
			}else {
				if (tx_queue_not_empty) 
				{
					pfring_zc_sync_queue(i->outzq, tx_only);
					tx_queue_not_empty = 0;
				}
				if (wait_for_packet) 
				{
					usleep(1);
				}
			}
			//////////////////////////////Critical Section////////////
			gettimeofday(&start,NULL);
			sem_wait(&os_sem);
			//cout<<"bushiba"<<endl;
			temp = Central_memory_tail;
			memcpy(temp+3,buffer,payloadlen);
			Central_memory_tail=Central_memory_tail+payloadlen+3;
			if(Central_memory_tail == second_buffer )
			{
				//cout<<"second"<<endl;
				pthread_join(thread4gpu[0], NULL);
				pthread_create(&thread4gpu[1],NULL,GPUKernelFunction_2,NULL);
				Central_memory_tail = Central_memory;
			}		
			if(Central_memory_tail  == first_buffer ) 
			{
				//cout<<"first"<<endl;
				pthread_join(thread4gpu[1], NULL);
				pthread_create(&thread4gpu[0],NULL,GPUKernelFunction_1,NULL);
			}
			sem_post(&os_sem);
			gettimeofday(&end,NULL);
			diff += 1000000*(end.tv_sec-start.tv_sec)+end.tv_usec-start.tv_usec;
			//////////////////////////////Critical Section////////////
		}
		/*pthread_join(thread4gpu[0], NULL);
		pthread_join(thread4gpu[1], NULL);*/

		if (!flush_packet) //after exit
		{
			pfring_zc_sync_queue(i->outzq, tx_only);
		}
		pfring_zc_sync_queue(i->inzq, rx_only);
		
#ifdef _test
		gpuoutput.close();
		all_test.close();
#endif
		sem_wait(&os_sem);
		cout<<"Ks: " <<kernel_sum << ", " << CountNumofPacketToGpuFun1 << "+" << CountNumofPacketToGpuFun2<<endl;
		sem_post(&os_sem);
		//cout << "insideTime: " << diff/1000000 << "." << diff%1000000 << endl;
		//cout << "GPUpre_time= " << diffGPU << endl;
	}
  ////////////////////////////////////////
	if(match_mode == 5) //partcial prefilter GPU
	{
		cout<<"In match_mode = 5 partcial prefilter GPU"<<endl;
		u_char* temp;
		int countpat1=0,counter1=0,counter2=0,counter3=0;
		unsigned char pak_pick1, pak_pick2,pak_pick3;
		int vt1_pos=0,count_t1_locat=0, win_no=0;
		int temp_test=0;
		int ingpubufcount = 0;
		while(!do_shutdown) 
		{
			if(pfring_zc_recv_pkt(i->inzq, &i->tmpbuff, wait_for_packet) > 0) 
			{
				if (unlikely(verbose)) 
				{
					char strbuf[4096];
					int strlen = sizeof(strbuf);
					int strused = snprintf(strbuf, strlen, "[%s -> %s]", i->in_dev, i->out_dev);
					pfring_print_pkt(&strbuf[strused], strlen - strused, pfring_zc_pkt_buff_data(i->tmpbuff, i->inzq), i->tmpbuff->len, i->tmpbuff->len);
					fputs(strbuf, stdout);
				}
				buffer = pfring_zc_pkt_buff_data(i->tmpbuff, i->inzq)+42;
				// printf("buffer: %d\n",*buffer);
				ingpubufcount++;
				i->numPkts++;
				i->numBytes += i->tmpbuff->len + 24; /* 8 Preamble + 4 CRC + 12 IFG */
				  
				errno = 0;
				while (unlikely(pfring_zc_send_pkt(i->outzq, &i->tmpbuff, flush_packet) < 0 && errno != EMSGSIZE && !do_shutdown)) //send packet
				if (wait_for_packet)
				{					
					usleep(1);
				}
				
				tx_queue_not_empty = 1;
			}else {
				if (tx_queue_not_empty) 
				{
					pfring_zc_sync_queue(i->outzq, tx_only);
					tx_queue_not_empty = 0;
				}
				if (wait_for_packet) 
				{
					usleep(1);
				}
			}
			
			//prefilter比對
			for(int i = 0 ; i < payloadlen-1 ; i=i+1 )
			{
				pak_pick1 = *(buffer+i);
				pak_pick2 = *(buffer+i+1);
				vt1_pos = (pak_pick1<<8) |pak_pick2;	
				//雙字元以上pat
				if(  *(T1_bool+vt1_pos) )
				{

					vt1_pos = pak_pick1*256+pak_pick2;
					win_no = vt1_pos/win_size;
					count_t1_locat = win_size*win_no;
					pak_pick3 = *(buffer+i+2);

				
					if( *(*(T2ptr+vt1_pos)+(pak_pick3/8)) &  (128 >> pak_pick3%8)  )
					{	

						counter3++;
						counter1=0;
						counter2=0;
							//////////////////////////////Critical Section////////////
							sem_wait(&os_sem);
							if(Central_memory_tail == second_buffer){
								pthread_join(thread4gpu[0], NULL);	
								pthread_create(&thread4gpu[1],NULL,GPUKernelFunction_4,NULL);
								Central_memory_tail = Central_memory;
							}	
							if(Central_memory_tail == first_buffer) {	
								pthread_join(thread4gpu[1], NULL);
								pthread_create(&thread4gpu[0],NULL,GPUKernelFunction_3,NULL);
							}
							Central_memory_tail+=payloadlen;
							temp = Central_memory_tail;
							sem_post(&os_sem);
							temp_test += i;


						//	if(i>110){
						//	*temp = i-110;
						//	*(temp+1) = ((i-110)>>8) &0xFF;
						//	}
							*temp = i;
							*(temp+1) = ((i)>>8) &0xFF;
					//cout<<"cpu__"<<i<<"       " <<(int)*temp<<"  "<<(int)*(temp+1);
							memcpy(temp,buffer,payloadlen);				
							//////////////////////////////Critical Section////////////
							break;
					}
				}
			}
			nfound=nfound+counter1+counter2;
			counter1=0;
			counter2=0;
		}

		if (!flush_packet) //after exit
		{
			pfring_zc_sync_queue(i->outzq, tx_only);
		}
		pfring_zc_sync_queue(i->inzq, rx_only);
		
#ifdef _test
		gpuoutput.close();
		all_test.close();
#endif
		printf("temp_test= %d, nfound =%d,counter = %d  //  %d  // counter[2]=%d //     kernel_sum =%d \n" ,temp_test,nfound,counter1,counter2,counter3,kernel_sum);
	}
  ////////////////////////////////////////
	if(match_mode == 2) //prefilter GPU
	{
		cout<<"In match_mode = 2 prefilter GPU"<<endl;
		u_char* temp;
		int countpat1=0,counter1=0,counter2=0,counter3=0;
		unsigned char pak_pick1, pak_pick2,pak_pick3;
		int vt1_pos=0,count_t1_locat=0, win_no=0;
		int temp_test=0;
		int ingpubufcount = 0;
		while(!do_shutdown) 
		{
			if(pfring_zc_recv_pkt(i->inzq, &i->tmpbuff, wait_for_packet) > 0) 
			{
				if (unlikely(verbose)) 
				{
					char strbuf[4096];
					int strlen = sizeof(strbuf);
					int strused = snprintf(strbuf, strlen, "[%s -> %s]", i->in_dev, i->out_dev);
					pfring_print_pkt(&strbuf[strused], strlen - strused, pfring_zc_pkt_buff_data(i->tmpbuff, i->inzq), i->tmpbuff->len, i->tmpbuff->len);
					fputs(strbuf, stdout);
				}
				buffer = pfring_zc_pkt_buff_data(i->tmpbuff, i->inzq)+42;
				// printf("buffer: %d\n",*buffer);
				ingpubufcount++;
				i->numPkts++;
				i->numBytes += i->tmpbuff->len + 24; /* 8 Preamble + 4 CRC + 12 IFG */
				  
				errno = 0;
				while (unlikely(pfring_zc_send_pkt(i->outzq, &i->tmpbuff, flush_packet) < 0 && errno != EMSGSIZE && !do_shutdown)) //send packet
				if (wait_for_packet)
				{					
					usleep(1);
				}
				
				tx_queue_not_empty = 1;
			}else {
				if (tx_queue_not_empty) 
				{
					pfring_zc_sync_queue(i->outzq, tx_only);
					tx_queue_not_empty = 0;
				}
				if (wait_for_packet) 
				{
					usleep(1);
				}
			}
			
			//prefilter比對
			for(int i = 0 ; i < payloadlen-1 ; i=i+1 )
			{
				pak_pick1 = *(buffer+i);
				pak_pick2 = *(buffer+i+1);
				vt1_pos = (pak_pick1<<8) |pak_pick2;  //pak_pick1*256+pak_pick2
				//雙字元以上pat
				if(  *(T1_bool+vt1_pos) )
				{

					vt1_pos = pak_pick1*256+pak_pick2;
					win_no = vt1_pos/win_size; //貌似沒用
					count_t1_locat = win_size*win_no; //貌似沒用
					pak_pick3 = *(buffer+i+2);
					

				
					if( *(*(T2ptr+vt1_pos)+(pak_pick3/8)) &  (128 >> pak_pick3%8)  )
					{	

						counter3++;
						counter1=0;
						counter2=0;
							//////////////////////////////Critical Section////////////
							sem_wait(&os_sem);
							if(Central_memory_tail == second_buffer){
								pthread_join(thread4gpu[0], NULL);	
								pthread_create(&thread4gpu[1],NULL,GPUKernelFunction_2,NULL);
								Central_memory_tail = Central_memory;
							}	
							if(Central_memory_tail == first_buffer) {	
								pthread_join(thread4gpu[1], NULL);
								pthread_create(&thread4gpu[0],NULL,GPUKernelFunction_1,NULL);
							}
							Central_memory_tail+=payloadlen;
							temp = Central_memory_tail;
							sem_post(&os_sem);
							memcpy(temp,buffer,payloadlen);				
							//////////////////////////////Critical Section////////////
							break;
					}
				}
			}
			nfound=nfound+counter1+counter2;
			counter1=0;
			counter2=0;
		}

		if (!flush_packet) //after exit
		{
			pfring_zc_sync_queue(i->outzq, tx_only);
		}
		pfring_zc_sync_queue(i->inzq, rx_only);
		
#ifdef _test
		gpuoutput.close();
		all_test.close();
#endif
		printf("temp_test= %d, nfound =%d,counter = %d  //  %d  // counter[2]=%d //     kernel_sum =%d \n" ,temp_test,nfound,counter1,counter2,counter3,kernel_sum);
	}
  ////////////////////////////////////////
	if(match_mode == 9) //test speed of transport cpu 2 gpu
	{
		cout<<"In match_mode = 9 test speed of transport cpu 2 gpu"<<endl;
		u_char* temp;
		int ingpubufcount = 0;
		while(!do_shutdown) 
		{
			if(pfring_zc_recv_pkt(i->inzq, &i->tmpbuff, wait_for_packet) > 0) 
			{
				if (unlikely(verbose)) 
				{
					char strbuf[4096];
					int strlen = sizeof(strbuf);
					int strused = snprintf(strbuf, strlen, "[%s -> %s]", i->in_dev, i->out_dev);
					pfring_print_pkt(&strbuf[strused], strlen - strused, pfring_zc_pkt_buff_data(i->tmpbuff, i->inzq), i->tmpbuff->len, i->tmpbuff->len);
					fputs(strbuf, stdout);
				}
				buffer = pfring_zc_pkt_buff_data(i->tmpbuff, i->inzq)+42;
				// printf("buffer: %d\n",*buffer);
				ingpubufcount++;
				i->numPkts++;
				i->numBytes += i->tmpbuff->len + 24; /* 8 Preamble + 4 CRC + 12 IFG */
				  
				errno = 0;
				while (unlikely(pfring_zc_send_pkt(i->outzq, &i->tmpbuff, flush_packet) < 0 && errno != EMSGSIZE && !do_shutdown)) //send packet
				if (wait_for_packet)
				{					
					usleep(1);
				}
				
				tx_queue_not_empty = 1;
			}else {
				if (tx_queue_not_empty) 
				{
					pfring_zc_sync_queue(i->outzq, tx_only);
					tx_queue_not_empty = 0;
				}
				if (wait_for_packet) 
				{
					usleep(1);
				}
			}
			//////////////////////////////Critical Section////////////
			sem_wait(&os_sem);
			//cout<<"bushiba"<<endl;
			if(Central_memory_tail == second_buffer )
			{
				//cout<<"second"<<endl;
				pthread_join(thread4gpu[0], NULL);
				pthread_create(&thread4gpu[1],NULL,GPUKernelFunction_9,NULL);
				Central_memory_tail = Central_memory;
			}		
			if(Central_memory_tail  == first_buffer ) 
			{
				//cout<<"first"<<endl;
				pthread_join(thread4gpu[1], NULL);
				pthread_create(&thread4gpu[0],NULL,GPUKernelFunction_8,NULL);
			}
			
			Central_memory_tail+=payloadlen;
			temp = Central_memory_tail;
			sem_post(&os_sem);
			memcpy(temp,buffer,payloadlen);
			//////////////////////////////Critical Section////////////
		}

		if (!flush_packet) //after exit
		{
			pfring_zc_sync_queue(i->outzq, tx_only);
		}
		pfring_zc_sync_queue(i->inzq, rx_only);
		
#ifdef _test
		gpuoutput.close();
		all_test.close();
#endif
		cout<<kernel_sum<<endl;
	}
  ////////////////////////////////////////
	if(match_mode == 8) //test prefilter throughput
	{
		cout<<"In match_mode = 8 test prefilter throughput"<<endl;
		u_char* temp;
		int countpat1=0,counter1=0,counter2=0,counter3=0;
		unsigned char pak_pick1, pak_pick2,pak_pick3;
		int vt1_pos=0,count_t1_locat=0, win_no=0;
		int temp_test=0;
		int ingpubufcount = 0;
		while(!do_shutdown) 
		{
			if(pfring_zc_recv_pkt(i->inzq, &i->tmpbuff, wait_for_packet) > 0) 
			{
				if (unlikely(verbose)) 
				{
					char strbuf[4096];
					int strlen = sizeof(strbuf);
					int strused = snprintf(strbuf, strlen, "[%s -> %s]", i->in_dev, i->out_dev);
					pfring_print_pkt(&strbuf[strused], strlen - strused, pfring_zc_pkt_buff_data(i->tmpbuff, i->inzq), i->tmpbuff->len, i->tmpbuff->len);
					fputs(strbuf, stdout);
				}
				buffer = pfring_zc_pkt_buff_data(i->tmpbuff, i->inzq)+42;
				// printf("buffer: %d\n",*buffer);
				ingpubufcount++;
				i->numPkts++;
				i->numBytes += i->tmpbuff->len + 24; /* 8 Preamble + 4 CRC + 12 IFG */
				  
				errno = 0;
				while (unlikely(pfring_zc_send_pkt(i->outzq, &i->tmpbuff, flush_packet) < 0 && errno != EMSGSIZE && !do_shutdown)) //send packet
				if (wait_for_packet)
				{					
					usleep(1);
				}
				
				tx_queue_not_empty = 1;
			}else {
				if (tx_queue_not_empty) 
				{
					pfring_zc_sync_queue(i->outzq, tx_only);
					tx_queue_not_empty = 0;
				}
				if (wait_for_packet) 
				{
					usleep(1);
				}
			}
			
			//prefilter比對
			for(int i = 0 ; i < payloadlen-1 ; i=i+1 )
			{
				pak_pick1 = *(buffer+i);
				pak_pick2 = *(buffer+i+1);
				vt1_pos = (pak_pick1<<8) |pak_pick2;	
				//雙字元以上pat
				if(  *(T1_bool+vt1_pos) )
				{

					vt1_pos = pak_pick1*256+pak_pick2;
					win_no = vt1_pos/win_size;
					count_t1_locat = win_size*win_no;
					pak_pick3 = *(buffer+i+2);

				
					if( *(*(T2ptr+vt1_pos)+(pak_pick3/8)) &  (128 >> pak_pick3%8)  )
					{	

						counter3++;
						counter1=0;
						counter2=0;
							//////////////////////////////Critical Section////////////
							/*sem_wait(&os_sem);
							if(Central_memory_tail == second_buffer){
								pthread_join(thread4gpu[0], NULL);	
								pthread_create(&thread4gpu[1],NULL,GPUKernelFunction_2,NULL);
								Central_memory_tail = Central_memory;
							}	
							if(Central_memory_tail == first_buffer) {	
								pthread_join(thread4gpu[1], NULL);
								pthread_create(&thread4gpu[0],NULL,GPUKernelFunction_1,NULL);
							}
							Central_memory_tail+=payloadlen;
							temp = Central_memory_tail;
							sem_post(&os_sem);
							memcpy(temp,buffer,payloadlen);	*/			
							//////////////////////////////Critical Section////////////
							break;
					}
				}
			}
			nfound=nfound+counter1+counter2;
			counter1=0;
			counter2=0;
		}

		if (!flush_packet) //after exit
		{
			pfring_zc_sync_queue(i->outzq, tx_only);
		}
		pfring_zc_sync_queue(i->inzq, rx_only);
		
#ifdef _test
		gpuoutput.close();
		all_test.close();
#endif
		printf("temp_test= %d, nfound =%d,counter = %d  //  %d  // counter[2]=%d //     kernel_sum =%d \n" ,temp_test,nfound,counter1,counter2,counter3,kernel_sum);
	}
  ////////////////////////////////////////
	if(match_mode == 6) //popcorn HPMA for cgc
	{
		int whoami = i->bind_core;
		cout << "whoami: " << whoami << endl;
		int counta=0, countf=0, counts=0;
		int counterbuffer=0;
		int checkbyT1 = 0;
		cout<<"In match_mode = 6 HPMA for cgc"<<endl;
		u_char* temp;
		int countpat1=0,counterT1=0,counterT2=0,counter3=0;
		unsigned char pak_pick1, pak_pick2,pak_pick3;
		int vt1_pos=0,count_t1_locat=0, win_no=0;
		int temp_test=0;
		int ingpubufcount = 0;
		int PidforT2=0;
		unsigned long long int postopop=0;
		int checkBT=0;
		int LastPid=0;
		int zeroTMP=0;
		u_char* bushibalol;
		pid_t getpid();
		while(!do_shutdown) 
		{
			if(pfring_zc_recv_pkt(i->inzq, &i->tmpbuff, wait_for_packet) > 0) 
			{
				if (unlikely(verbose)) 
				{
					char strbuf[4096];
					int strlen = sizeof(strbuf);
					int strused = snprintf(strbuf, strlen, "[%s -> %s]", i->in_dev, i->out_dev);
					pfring_print_pkt(&strbuf[strused], strlen - strused, pfring_zc_pkt_buff_data(i->tmpbuff, i->inzq), i->tmpbuff->len, i->tmpbuff->len);
					fputs(strbuf, stdout);
				}
				//bushibalol = pfring_zc_pkt_buff_data(i->tmpbuff, i->inzq)+41;
				//cout << "bushibalol: " << (int)*bushibalol  << endl;
				buffer = pfring_zc_pkt_buff_data(i->tmpbuff, i->inzq)+42;
				//printf("buffer: %x, %x, %x\n",*buffer,*(buffer+1),*(buffer+2));
				ingpubufcount++;
				i->numPkts++;
				i->numBytes += i->tmpbuff->len + 24; /* 8 Preamble + 4 CRC + 12 IFG */
				  
				errno = 0;
				while (unlikely(pfring_zc_send_pkt(i->outzq, &i->tmpbuff, flush_packet) < 0 && errno != EMSGSIZE && !do_shutdown)) //send packet
				if (wait_for_packet)
				{					
					usleep(1);
				}
				
				tx_queue_not_empty = 1;
			}else {
				if (tx_queue_not_empty) 
				{
					pfring_zc_sync_queue(i->outzq, tx_only);
					tx_queue_not_empty = 0;
				}
				if (wait_for_packet) 
				{
					usleep(1);
				}
			}
			
			//prefilter比對
			bool checkifT1 = false;
			gettimeofday(&start,NULL);
			//counta++;
			for(int i = 0 ; i < payloadlen-2 ; i=i+1 )
			{
				pak_pick1 = *(buffer+i);
				pak_pick2 = *(buffer+i+1);
				vt1_pos = (pak_pick1<<8) |pak_pick2;  //pak_pick1*256+pak_pick2
				//雙字元以上pat
				
				//if(  *(T1b_bool+vt1_pos) )
				if( CheckT1((int)vt1_pos) )
				{
					checkifT1 = true;
					counterT1++;
					//vt1_pos = pak_pick1*256+pak_pick2;
					win_no = vt1_pos/win_size; //貌似沒用
					count_t1_locat = win_size*win_no; //貌似沒用
					pak_pick3 = *(buffer+i+2);
					
					//postopop = BitArrayToInt(T1b_bool,(vt1_pos/64)*64,vt1_pos);
					checkBT = (int)BT[vt1_pos/64];
					//PidforT2 = checkBT + popcount_3(postopop);
					PidforT2 = checkBT + BitCount(T1_char, (vt1_pos & 0xfffffc0) ,vt1_pos);
					
					//cout << (vt1_pos%64)*64 << ", " << ((vt1_pos%64)+1)*64 <<endl;
					//cout << PidforT2 << "= " << checkBT << " + " << "popcount_3(" << postopop << ")  " << popcount_3(postopop) << "."  <<endl;

					//if (T2_bool[PidforT2*256+pak_pick3])
					if( CheckT2(PidforT2*256+(int)pak_pick3) )
					{
						//sem_wait(&os_sem);
						//cout << "PidforT2: " << PidforT2 << ", " ;
						//cout <<"numofpacket: " << i  <<" '"<< (int)pak_pick1<<"' '" << (int)pak_pick2<<"' '"<< (int)pak_pick3 << "', '" << pak_pick1 << "' '" << pak_pick2 << "' '" << pak_pick3 <<"'\t" << LastPid << "= (" << checkBT << "+" << popcount_3(postopop) << ")*256+" << (int)pak_pick3 <<  endl;
						//outputyo << i << ": " << pak_pick1 << pak_pick2 << pak_pick3 << endl;
						//sem_post(&os_sem);
						counterT2++;
							//////////////////////////////Critical Section////////////
							sem_wait(&os_sem);
							//gettimeofday(&startCPU,NULL);
							temp = Central_memory_tail;
							//memcpy(temp,&i,2);
							memcpy(temp,&zeroTMP,2);
							memcpy(temp+2,&whoami,1);

							memcpy(temp+3,buffer,payloadlen);
							Central_memory_tail = Central_memory_tail + payloadlen + 3;
							//counterbuffer++;
							//printf("%d\n",counterbuffer);
							if(Central_memory_tail == second_buffer){
								//cout << "////////-----second is full-----////////" << endl;
								//counts++;
								pthread_join(thread4gpu[0], NULL);	
								pthread_create(&thread4gpu[1],NULL,GPUKernelFunction_2,NULL);
								Central_memory_tail = Central_memory;
							}	
							if(Central_memory_tail == first_buffer) {	
								//cout << "////////-----first is full-----/////////" << endl;
								//countf++;
								pthread_join(thread4gpu[1], NULL);
								pthread_create(&thread4gpu[0],NULL,GPUKernelFunction_1,NULL);
							}
							//gettimeofday(&endCPU,NULL);
							//diffCPU += 1000000*(endCPU.tv_sec-startCPU.tv_sec)+endCPU.tv_usec-startCPU.tv_usec;
							sem_post(&os_sem);
							//////////////////////////////Critical Section////////////
							break;
					}
				}
			}
			if(checkifT1 == true)
			{
				checkbyT1++;
			}
			/*sem_wait(&os_sem);
			pthread_join(thread4gpu[0], NULL);
			pthread_join(thread4gpu[1], NULL);
			sem_post(&os_sem);*/
			gettimeofday(&end,NULL);
			diff += 1000000*(end.tv_sec-start.tv_sec)+end.tv_usec-start.tv_usec;
		}
		//sem_wait(&os_sem);
		//outputyo << "countT1= " << counterT1 << ", counterT2= " << counterT2 << ", countGPU= " << kernel_sum << ", prefilter_time= " << diff << endl;
		//sem_post(&os_sem);
		if (!flush_packet) //after exit
		{
			pfring_zc_sync_queue(i->outzq, tx_only);
		}
		pfring_zc_sync_queue(i->inzq, rx_only);


#ifdef _test
		//gpuoutput.close();
		all_test.close();
#endif
		//printf("temp_test= %d, nfound =%d,counter = %d  //  %d  // counter[2]=%d //     kernel_sum =%d  time = %ld \n" ,temp_test,nfound,counter1,counter2,counter3,kernel_sum, diff);
		int CNOPTG = CountNumofPacketToGpuFun1+CountNumofPacketToGpuFun2 ;
		//sem_wait(&os_sem);
		//outputyo << counterT1 << " " << checkbyT1 << " " << counterT2 << " " <<kernel_sum << " " << CNOPTG << " " << diff << endl;
		//sem_post(&os_sem);
		printf("countT1= %d, checkbyT1= %d, countT2= %d, countGPU= %d, Pak2GPU= %d+%d, pre_time= %d, GPUpre_time= %d\n",counterT1,checkbyT1,counterT2,kernel_sum, CountNumofPacketToGpuFun1, CountNumofPacketToGpuFun2, diff, diffGPU);
		/*sem_wait(&os_sem);
		outputyo << "pre= " << diff << ", cpu= " << diffCPU << ", newthread= " << diffGPU << ", cuda= " << diffCUDA << endl;
		sem_post(&os_sem);*/
	}
  ////////////////////////////////////////
	if(match_mode == 3) //popcorn HPMA for cgcv2
	{
		int counterbuffer=0;
		int checkbyT1 = 0;
		cout<<"In match_mode = 3 HPMAv2 for cgcv2"<<endl;
		u_char* temp;
		int countpat1=0,counterT1=0,counterT2=0,counter3=0;
		unsigned char pak_pick1, pak_pick2,pak_pick3;
		int vt1_pos=0,count_t1_locat=0, win_no=0;
		int temp_test=0;
		int ingpubufcount = 0;
		int PidforT2=0;
		unsigned long long int postopop=0;
		int checkBT=0;
		int LastPid=0;
		u_char* bushibalol;
		pid_t getpid();
		while(!do_shutdown) 
		{
			if(pfring_zc_recv_pkt(i->inzq, &i->tmpbuff, wait_for_packet) > 0) 
			{
				if (unlikely(verbose)) 
				{
					char strbuf[4096];
					int strlen = sizeof(strbuf);
					int strused = snprintf(strbuf, strlen, "[%s -> %s]", i->in_dev, i->out_dev);
					pfring_print_pkt(&strbuf[strused], strlen - strused, pfring_zc_pkt_buff_data(i->tmpbuff, i->inzq), i->tmpbuff->len, i->tmpbuff->len);
					fputs(strbuf, stdout);
				}
				//bushibalol = pfring_zc_pkt_buff_data(i->tmpbuff, i->inzq)+41;
				//cout << "bushibalol: " << (int)*bushibalol  << endl;
				buffer = pfring_zc_pkt_buff_data(i->tmpbuff, i->inzq)+42;
				//printf("buffer: %x, %x, %x\n",*buffer,*(buffer+1),*(buffer+2));
				ingpubufcount++;
				i->numPkts++;
				i->numBytes += i->tmpbuff->len + 24; /* 8 Preamble + 4 CRC + 12 IFG */
				  
				errno = 0;
				while (unlikely(pfring_zc_send_pkt(i->outzq, &i->tmpbuff, flush_packet) < 0 && errno != EMSGSIZE && !do_shutdown)) //send packet
				if (wait_for_packet)
				{					
					usleep(1);
				}
				
				tx_queue_not_empty = 1;
			}else {
				if (tx_queue_not_empty) 
				{
					pfring_zc_sync_queue(i->outzq, tx_only);
					tx_queue_not_empty = 0;
				}
				if (wait_for_packet) 
				{
					usleep(1);
				}
			}
			
			//prefilter比對
			bool checkifT1 = false;
			gettimeofday(&start,NULL);
			for(int i = 0 ; i < payloadlen-2 ; i=i+1 )
			{
				pak_pick1 = *(buffer+i);
				pak_pick2 = *(buffer+i+1);
				vt1_pos = (pak_pick1<<8) |pak_pick2;  //pak_pick1*256+pak_pick2
				//雙字元以上pat
				
				//if(  *(T1b_bool+vt1_pos) )
				if( CheckT1((int)vt1_pos) )
				{
					checkifT1 = true;
					counterT1++;
					//vt1_pos = pak_pick1*256+pak_pick2;
					win_no = vt1_pos/win_size; //貌似沒用
					count_t1_locat = win_size*win_no; //貌似沒用
					pak_pick3 = *(buffer+i+2);
					
					//postopop = BitArrayToInt(T1b_bool,(vt1_pos/64)*64,vt1_pos);
					checkBT = (int)BT[vt1_pos/64];
					//PidforT2 = checkBT + popcount_3(postopop);
					PidforT2 = checkBT + BitCount(T1_char, (vt1_pos & 0xfffffc0) ,vt1_pos);
					
					//cout << (vt1_pos%64)*64 << ", " << ((vt1_pos%64)+1)*64 <<endl;
					//cout << PidforT2 << "= " << checkBT << " + " << "popcount_3(" << postopop << ")  " << popcount_3(postopop) << "."  <<endl;

					//if (T2_bool[PidforT2*256+pak_pick3])
					if( CheckT2(PidforT2*256+(int)pak_pick3) )
					{
						//sem_wait(&os_sem);
						//cout << "PidforT2: " << PidforT2 << ", " ;
						//cout <<"numofpacket: " << i  <<" '"<< (int)pak_pick1<<"' '" << (int)pak_pick2<<"' '"<< (int)pak_pick3 << "', '" << pak_pick1 << "' '" << pak_pick2 << "' '" << pak_pick3 <<"'\t" << LastPid << "= (" << checkBT << "+" << popcount_3(postopop) << ")*256+" << (int)pak_pick3 <<  endl;
						//outputyo << i << ": " << pak_pick1 << pak_pick2 << pak_pick3 << endl;
						//sem_post(&os_sem);
						counterT2++;
							//////////////////////////////Critical Section////////////
							sem_wait(&os_sem);
							gettimeofday(&startCPU,NULL);
							//cout << "CPU: " << i << "; "<< (int)*(buffer+i) << ", " << (int)*(buffer+i+1) << endl;
							temp = Central_memory_tail;
							/*test*/
							/**temp = ((i)>>8);
							*(temp+1) = i & 0xFF;*/
							//cout << "cpu: " << i << "  " << setw(5) << (int)*temp << "  " << setw(5) << (int) *(temp+1) << endl;
							/*test*/
							//cout << (unsigned char*)&i << endl;
							//int tempi=1000;
							//memcpy(temp,&tempi,2);
							
							//int yo = 1458;
							//memcpy(temp,&yo,2);
							memcpy(temp,&i,2);
							
							
							//*temp = ((unsigned char*)(&i))[0];
							//*(temp+1) = ((unsigned char*)(&i))[1];
							memcpy(temp+3,buffer,payloadlen);
							Central_memory_tail = Central_memory_tail + payloadlen +3;
							counterbuffer++;
							//printf("%d\n",counterbuffer);
							if(Central_memory_tail == second_buffer){
								//cout << "////////-----second is full-----////////" << endl;
								pthread_join(thread4gpu[0], NULL);	
								pthread_create(&thread4gpu[1],NULL,GPUKernelFunction_4,NULL);
								Central_memory_tail = Central_memory;
							}	
							if(Central_memory_tail == first_buffer){	
								//cout << "////////-----first is full-----/////////" << endl;
								pthread_join(thread4gpu[1], NULL);
								pthread_create(&thread4gpu[0],NULL,GPUKernelFunction_3,NULL);
							}
							//
							gettimeofday(&endCPU,NULL);
							diffCPU += 1000000*(endCPU.tv_sec-startCPU.tv_sec)+endCPU.tv_usec-startCPU.tv_usec;
							sem_post(&os_sem);
							//////////////////////////////Critical Section////////////
							break;
					}
				}
			}
			if(checkifT1 == true)
			{
				checkbyT1++;
			}

			gettimeofday(&end,NULL);
			diff += 1000000*(end.tv_sec-start.tv_sec)+end.tv_usec-start.tv_usec;
		}
		//sem_wait(&os_sem);
		//outputyo << "countT1= " << counterT1 << ", counterT2= " << counterT2 << ", countGPU= " << kernel_sum << ", prefilter_time= " << diff << endl;
		//sem_post(&os_sem);
		if (!flush_packet) //after exit
		{
			pfring_zc_sync_queue(i->outzq, tx_only);
		}
		pfring_zc_sync_queue(i->inzq, rx_only);


#ifdef _test
		//gpuoutput.close();
		all_test.close();
#endif
		//printf("temp_test= %d, nfound =%d,counter = %d  //  %d  // counter[2]=%d //     kernel_sum =%d  time = %ld \n" ,temp_test,nfound,counter1,counter2,counter3,kernel_sum, diff);
		int CNOPTG = CountNumofPacketToGpuFun1+CountNumofPacketToGpuFun2 ;
		/*sem_wait(&os_sem);
		outputyo << counterT1 << " " << checkbyT1 << " " << counterT2 << " " <<kernel_sum << " " << CNOPTG << " " << diff << endl;
		sem_post(&os_sem);*/
		printf("countT1= %d, checkbyT1= %d, countT2= %d, countGPU= %d, Pak2GPU= %d+%d, pre_time= %d, GPUpre_time= %d\n",counterT1,checkbyT1,counterT2,kernel_sum, CountNumofPacketToGpuFun1, CountNumofPacketToGpuFun2, diff, diffGPU);
		//printf("pre= %d, cpu= %d, gpu= %d, cuda= %d",diff,diffCPU,diffGPU,diffCUDA);
		/*sem_wait(&os_sem);
		outputyo << "pre= " << diff << ", cpu= " << diffCPU << ", cudaingpu= " << diffGPU << ", newthread= " << diffCUDA << endl;
		sem_post(&os_sem);*/
	}
  ////////////////////////////////////////
  
  
  
  return NULL;
}

/* *************************************** */

int init_direction(struct dir_info *i, char *in_dev, char *out_dev) {
  
  cout<<" in: "<<in_dev<<" out: "<<out_dev<<endl;

  i->in_dev = in_dev;
  i->out_dev = out_dev;

  i->tmpbuff = pfring_zc_get_packet_handle(zc);

  if (i->tmpbuff == NULL) {
    fprintf(stderr, "pfring_zc_get_packet_handle error\n");
    return -1;
  }

  i->inzq = pfring_zc_open_device(zc, in_dev, rx_only, 0);

  if(i->inzq == NULL) {
    fprintf(stderr, "pfring_zc_open_device error [%s] Please check that %s is up and not already used\n",
     	    strerror(errno), in_dev);
    return -1;
  }

  i->outzq = pfring_zc_open_device(zc, out_dev, tx_only, 0);

  if(i->outzq == NULL) {
    fprintf(stderr, "pfring_zc_open_device error [%s] Please check that %s is up and not already used\n",
	    strerror(errno), out_dev);
    return -1;
  }

  return 0;
}

/* *************************************** */

int main(int argc, char* argv[]) {
  char *device1 = NULL, *device2 = NULL;
  char *device1_rss[num_threads], *device2_rss[num_threads];
  char *device1_rss_NIC[num_threads], *device2_rss_NIC[num_threads];
  char *bind_mask = NULL, c;
  long i, j, k, m, n;
  stringstream ss;
  string idder;
  char *device_at     = "@";
  char *device_10_in  = "zc:ens10f1";
  char *device_10_out = "zc:ens10f0";

//#ifdef _test
	gpuoutput.open("gpuoutput.txt",ios::out|ios::trunc);
	gpuoutput << "Main" << endl;
//#endif
  
  outputyo.open("outputyo",ios::out);
  //int cluster_id = DEFAULT_CLUSTER_ID+9; 
  u_int numCPU = sysconf( _SC_NPROCESSORS_ONLN );
  //pattern
  ifstream inFile;
  string line;
  //mwm
  int nocase=1, npats=0;

  cout << "numCPU: " << numCPU << endl;

  //dir[0].bind_core = dir[1].bind_core = -1;
    for(int i=0;i<32;i++)
    {
    	dir[i].bind_core = -1;
    }

  startTime.tv_sec = 0;

	while((c = getopt(argc,argv,"abc:e:g:hi:j:n:N:o:s:t:fv")) != '?') {
		if((c == 255) || (c == -1)) break;

		switch(c) {
			case 'h':
			printHelp();
			break;
		case 'a':
			wait_for_packet = 0;
			break;
		case 'f':
			flush_packet = 1;
			break;
		case 'v':
			verbose = 1;
			break;
		case 'b':
			bidirectional = 1;
			break;
		case 'c':
			cluster_id = atoi(optarg);
			break;
		case 'i':
			device1 = strdup(optarg);
			break;
		case 'o':
			device2 = strdup(optarg);
			break;
		case 'g':
			bind_mask = strdup(optarg);
			break;
		case 'e':
			match_mode = atoi(optarg);
			break;
		case 'n':
			num_threads = atoi(optarg);
			break;
		case 'N':
			two_NIC = atoi(optarg);
			break;
		case 's':
			blocksNumper = atoi(optarg);
			printf("\n blocksNumper =%d  ",blocksNumper);
			break;
		case 't':
			threadsperBlock = atoi(optarg);
			printf("\n threadsperBlock = %d\n",threadsperBlock);
			break;
		case 'j':
			rec_pkt_size = atoi(optarg);
			break;
    }
  }
  
  if (device1 == NULL) printHelp();
  if (device2 == NULL) printHelp();
  if (cluster_id < 0)  printHelp();

  /*if(bind_mask != NULL) {
    char *id;
    if ((id = strtok(bind_mask, ":")) != NULL)
      dir[0].bind_core = atoi(id) % numCPU;
    if ((id = strtok(NULL, ":")) != NULL)
      dir[1].bind_core = atoi(id) % numCPU;
  }*/
  if(bind_mask != NULL)
  {
    char *id = strtok(bind_mask, ":");
    int idx = 0;
	cout<<"id: ";
    while(id != NULL)
    {
      dir[idx++].bind_core = atoi(id) % numCPU;
	  cout << atoi(id) <<" ";
      if(idx >= num_threads) break;
      id = strtok(NULL, ":");
    }
	cout<<endl;
  }
	
	///// 12/06 for match_mode 4 GPU-AC //1227 test time of bytes
	buffer_size = blocksNumper*threadsperBlock;
	bytes = sizeof(u_char)*buffer_size*(payloadlen+3);
		cout<<"bytes = "<<bytes<<endl;
	
	nfound_GPU1=(int*)malloc(sizeof(int)*blocksNumper*threadsperBlock*4);
	nfound_GPU2=(int*)malloc(sizeof(int)*blocksNumper*threadsperBlock*4);
	Tablehits1=(bool*)malloc(sizeof(bool)*blocksNumper*threadsperBlock);
	Tablehits2=(bool*)malloc(sizeof(bool)*blocksNumper*threadsperBlock);
	cudaMalloc((void**)&d_nfound_GPU1,sizeof(int)*blocksNumper*threadsperBlock*4);
	cudaMalloc((void**)&d_nfound_GPU2,sizeof(int)*blocksNumper*threadsperBlock*4);
	cudaMalloc((void**)&d_Tablehits1,sizeof(bool)*blocksNumper*threadsperBlock);
	cudaMalloc((void**)&d_Tablehits2,sizeof(bool)*blocksNumper*threadsperBlock);
	cudaMalloc((void**)&d_T1_char,65536/8);
	cudaMalloc((void**)&d_T2_char,53760/8);
	memset(nfound_GPU1,0,sizeof(int)*blocksNumper*threadsperBlock*4);
	memset(nfound_GPU2,0,sizeof(int)*blocksNumper*threadsperBlock*4);
	memset(Tablehits1,0,sizeof(bool)*blocksNumper*threadsperBlock);
	memset(Tablehits1,0,sizeof(bool)*blocksNumper*threadsperBlock);
	cudaMemset(d_nfound_GPU1,0,sizeof(int)*blocksNumper*threadsperBlock*4);
	cudaMemset(d_nfound_GPU2,0,sizeof(int)*blocksNumper*threadsperBlock*4);
	
	counterGpuSnort=(int*)malloc(sizeof(int)*blocksNumper*threadsperBlock*4);
	memset(counterGpuSnort,0,sizeof(int)*blocksNumper*threadsperBlock*4);
	
	cudaMalloc((void**)&d_counterGpuSnort,sizeof(int)*blocksNumper*threadsperBlock*4);
	cudaMemset(d_counterGpuSnort,0,sizeof(int)*blocksNumper*threadsperBlock*4);

	for(int i=0;i<8;i++) //bitmasks 128, 64, 32, 16, 8, 4, 2, 1
	{
		bitmasks[i] = pow(2,7-i);
		//		printf("%d :: bitmask = %u \n", i ,bitmasks[i]);
	}
	
	//cudaMallocHost((void**)&d_fullTable,sizeof(u_char)*65536*128/4);
	//*nfound_GPU=0;
	sem_init(&os_sem,0,1);
	int* partcial_sum;
	//比對所需之宣告
	//cudaMallocHost((void**)&P_buffer,bytes);
	cudaMallocHost((void**)&Central_memory,4*bytes);//3
	cudaMalloc((void**)&d_Central_memory,4*bytes);
	//cudaMalloc((void**)&fullTable,65536*128/4);
	memset(Central_memory,0,4*bytes);
	cudaMemset(d_Central_memory,0,4*bytes);
	
	/////
	//Central_memory & buffer address initial
	Central_memory_tail =Central_memory;
	first_buffer = Central_memory + bytes;
	second_buffer = Central_memory + 2*bytes;
	
	
	///////////////////////////////////  12/10 for T1 BT T2 (match_mode 5) 
	FILE *fptr;
	fptr = fopen( T1_FILE_PATH ,"r");	
	t1size = GetFileLength(fptr);
  

	T1pid = (unsigned char*)malloc(t1size/2*sizeof(u_char));
	printf("T1 size:%d \n", t1size);
	T1 = (unsigned char*)malloc(t1size*sizeof(char));
	if( T1 == NULL )
	{
		fprintf(stderr, "記憶體不足\n");
		exit(1);
	}//fgets( T1 , t1size , fptr );
	//write into mem
	for( i = 0 ; i < t1size ; i++ )
	{
		T1[i] = fgetc(fptr);
		
		//T1pid[i*2]  =(T1[i]>>4 & 0x1);		
		//T1pid[i*2+1] = (T1[i]  & 0x1);	
	}
	cout<<"13132\n"<<sizeof(unsigned)<<endl<<sizeof(u_char)<<endl;
	for(int i =0 ; i<t1size/4; i++)
	{
		T1pid[i] =(u_char)(( T1[i*4]>>4 & 0x1) + (T1[i*4] & 0x1)*2	 +  (T1[i*4+1]>>4 & 0x1)*4 + (T1[i*4+1] & 0x1)*8 +
						(T1[i*4+2]>>4 & 0x1)*16 + (T1[i*4+2] & 0x1)*32+	  (T1[i*4+3]>>4 & 0x1)*64 + (T1[i*4+3] & 0x1)*128	); 
	}

	T1pidInt = (unsigned *)malloc(t1size/16*sizeof(unsigned));

	T1pidTemp = (unsigned *)malloc(t1size/2*sizeof(unsigned));
	for(int i = 0 ;i <t1size/16 ; i++)
	{
		for(int j= 0 ; j<16 ; j++){
		T1pidInt[i] += (unsigned)(( T1[i*16+j]>>4 &0x1) * pow(2,2*j));
	
	//	printf("%d test1 =  %llu      ,i= %d,j=%d\n",2*j,T1pidInt[i],i,j);
		T1pidInt[i] += (unsigned)(( T1[i*16+j] &0x1) * pow(2,2*j+1));

	//	printf("%d test1 =  %llu      ,i= %d,j=%d\n",2*j+1,T1pidInt[i],i,j);
		}

	}

/*
	for(int i =0 ; i <t1size/4 ; i++)
	{
		int a =	T1[j*4/8] & 128>> (j*4%8+3) ;
		int b = T1pid[j/8] &( 0x1 <<j%8)     ;
		if( a>0)
		{
			if(b<=0)
			{					
				cout<<"   "<<a<<"  "<<b<<"  "<<i;
			}
		}else if(b>=0)
		{
			cout<<"   "<<a<<"  "<<b<<"  "<<i;			
		}
	}

	cout<<" teststset   hello  popcnt_naive ="<<	popcnt_naive((unsigned*)T1pidTemp,1)<<endl;
	//cout<<"    hello  popcnt_ssse3 ="<<	popcount_ssse3((unsigned*)T1pid,2)<<endl;
	cout<<"    hello  popcnt_lauradoux ="<<	popcount_lauradoux((unsigned*)T1pid,2)<<endl;
	cout<<"    hello  popcnt_ssse2 ="<<	popcount_sse2_8bit((unsigned*)T1pid,2)<<endl;
	printf("%d   %d   %d    %d        %d  T1 szie: %d      \n",T1[0],T1[1],T1[2],T1[3], T1pid[0],t1size);
	cout<<" \n   "<<(int)	*T1pid<<endl;
*/
	fptr = fopen( BT_FILE_PATH ,"r");
  
	btsize = GetFileLength(fptr);
	BT = (unsigned char*)malloc(btsize*sizeof(char));
	if( BT == NULL )
	{
		fprintf(stderr, "記憶體不足\n");
		exit(1);
	}
	for( i = 0 ; i < btsize ; i++ )
	{
		BT[i] = fgetc(fptr);
	}
	cout << "btsize: " << btsize << endl;
	cout << "testBT: ";
	for( int testBT=0; testBT<10; testBT++)
	{
		cout << (int)BT[testBT] << " ";	
	}
	cout << endl;
  
	fptr = fopen( T2_FILE_PATH ,"r");
	t2size = GetFileLength(fptr);
	T2 = (unsigned char*)malloc(t2size*sizeof(char));
	if( T2 == NULL )
	{
		fprintf(stderr, "記憶體不足\n");
		exit(1);
	}
	for( i = 0 ; i < t2size ; i++ )
	{
		T2[i] = fgetc(fptr);
	}
  
  
	fclose(fptr);
  
	win_size = 65536/btsize;
 
	printf("win_size = %d   btsize = %d  t2size = %d t1size = %d \n",win_size, btsize,t2size,t1size);
	
	///////////////////////////////////  12/10 for T1_bool (match_mode 5)
	T1_bool =(bool*)malloc(256*256*sizeof(bool));
	for(int c_1 = 0; c_1< 255; c_1++)
	{
		for( int c_2 = 0 ; c_2 < 255;  c_2++)
		{
			int charIndex = c_1*255+c_2;
			T1_bool[charIndex]= T1[ charIndex*4/8] & (bitmasks[(charIndex*4)%8+3]);
		}
	}
	
	//////////20190427for T1b_FILE_PATH
	
	fptr = fopen( T1b_FILE_PATH ,"r");
	t1bsize = GetFileLength(fptr);
	
	cout << "t1bsize: " << t1bsize << endl;
	
	T1b = (unsigned char*)malloc(t1bsize*sizeof(u_char));
	if( T1b == NULL )
	{
		fprintf(stderr, "記憶體不足\n");
		exit(1);
	}
	for (int i=0;i<t1bsize;i++) //655360 = 256*256
	{
		T1b[i] = fgetc(fptr);
		//ss << T2b[i];
		//ss >> boolalpha  >> T2_bool[i];
		T1b_bool[i] = T1b[i]&1;
	}
	
	fclose(fptr);

	/////////20190605 for T1_char

	fptr = fopen( T1c_FILE_PATH , "r");
	t1csize = GetFileLength(fptr);

	cout << "t1csize: " << t1csize << endl;
	T1c = (unsigned char*)malloc(t1csize*sizeof(u_char));
	if( T1c == NULL )
	{
		fprintf(stderr, "記憶體不足\n");
		exit(1);
	}
	for(int i=0;i<t1csize;i++) //8192
	{
		T1_char[i] = fgetc(fptr);

	}
	// string b=bitset<8>(a).to_string();
	cout << "T1_char[0]: " << bitset<8>(T1_char[0]) << ", " << bitset<8>(T1_char[1])  << endl;
	cout << "T1_char[8192]: " << bitset<8>(T1_char[8191]) << endl;
	
	for(int i=0;i<10;i++)
	{
		cout << "CheckT1:" << CheckT1(i) << endl;
	}
	
	cout << "CheckBUSHIBA: " << CheckT1(101*256+110) << endl;

	for(int i=0;i<255;i++)
	{
		if( *(T1b_bool+i) != CheckT1(i) )
		{
			cout << "Different!!! at: " << i  << endl;
		}
	}

	fclose(fptr);

	/////////20190718 for T2_char

	fptr = fopen( T2c_FILE_PATH , "r");
	t2csize = GetFileLength(fptr);

	cout << "t2csize: " << t2csize << endl;
	T2c = (unsigned char*) malloc(t2csize*sizeof(u_char));
	if( T2c == NULL )
	{
		fprintf(stderr, "記憶體不足\n");
		exit(1);
	}
	for(int i=0;i<t2csize;i++) //6944
	{
		T2_char[i] = fgetc(fptr);
	}

	cout << "T2_char[0]: " << bitset<8>(T2_char[0]) << ", " << bitset<8>(T2_char[1]) << endl;
	cout << "T2_char[6944]: " << bitset<8>(T2_char[6943]) << endl;
	
	for(int i=0;i<10;i++)
	{
		cout << "CheckT2: " << CheckT2(i) << endl;
	}
	
	/*for(int i=0;i<256;i++)
	{
		if( *(T2_bool+i) != CheckT2(i) )
		{
			cout << "Different!!! at: " << i << endl;
		}
	}*/

	fclose(fptr);


	
	/////////20190315 for popcount
	unsigned long long int numof64;
	numof64 = BitArrayToInt(T1_bool,11840,11891);
	cout << "numof64: " << numof64 << endl;
	cout << "popcount_3: " << popcount_3(numof64) << endl;
	
	fptr = fopen( T2b_FILE_PATH ,"r");
	t2bsize = GetFileLength(fptr);

	cout << "t2bsize: " << t2bsize << endl;
	
	//stringstream T2ss;
	T2b = (unsigned char*)malloc(t2bsize*sizeof(u_char));
	if( T2b == NULL )
	{
		fprintf(stderr, "記憶體不足\n");
		exit(1);
	}
	for (int i=0;i<t2bsize;i++)
	{
		T2b[i] = fgetc(fptr);
		//ss << T2b[i];
		//ss >> boolalpha  >> T2_bool[i];
		T2_bool[i] = T2b[i]&1;
	}

  /////////////////////////////////////  12/11 for T2ptr (match_mode 5) 
	int charIndex = 0;
	int charIndex_winsize = 0;
	//int local_sum =0;
	int t2Loc = 0;
	int counterTest =0 ;
	//r = udaMallocManaged(&(fullTable),(65536*128));//2^16 *  2^7  / bytes
	//r = cudaMallocManaged(&(d_fullTable),sizeof(u_char)*65536*32);
	
	fullTable = (u_char*)malloc(65536*32);
	for(int c_1 = 0; c_1< 256; c_1++){
		for( int c_2 = 0 ; c_2 < 256;  c_2++){
			charIndex = c_1*256+c_2;
			charIndex_winsize=	charIndex-(charIndex%win_size); //貌似沒用
			//local_sum = 0;
			
			if(T1[ charIndex*4/8] & (bitmasks[(charIndex*4)%8+3]) )
			{
				for(int i = 0 ; i <32; i++)
				{	
						//fullTable[charIndex*32+i]=T2[t2Loc*32+i];
						fullTable[charIndex*32+i]=T2_char[t2Loc*32+i];
						counterTest++;
				}
				T2ptr[charIndex] = &T2[t2Loc*32];	
				t2Loc++;
				//t2Loc = BT[charIndex/win_size]+local_sum;
				//T2_bool[charIndex] = &T2b[t2Loc*32];
			}else{
				for(int i = 0 ; i <32; i++)
				{	
					fullTable[charIndex*32+i]=0;
				}	
				T2ptr[charIndex] =NULL;
			}		
		}
	}
	
	for(int i = 0 ; i<65536 ; i++)
	{
		if(T2ptr[i])
		{
			t2Loc--;
		}			
	}
	
	cout<<"counterTest  "<<counterTest<<endl<<"t2Loc  "<<t2Loc<<endl;
	
	unsigned int tt[5];
	memcpy(tt,fullTable,3);
	for(int i=0;i<10;i++)
	{
		for(int j=0;j<32;j++)
		{
			cout << (int)fullTable[i*32+j] << " " ;
		}
		cout << endl;
	}
	//cout<< tt[0] <<endl;
	//printf("test stemp  ans=%d   %d   %d   %d  \n",fullTable[96],fullTable[65],fullTable[66],fullTable[67]);
	//printf("test stemp  ans=%d   %d   %d   %d  \n",fullTable[36],fullTable[37],fullTable[38],fullTable[39]);

	//memcpy(d_fullTable,fullTable,65536*32);
	cudaMalloc((void**)&d_fullTable,sizeof(u_char)*65536*32);
	printf("test 1 \n");
	
	cudaMemcpy(d_fullTable,fullTable,65536*32,cudaMemcpyHostToDevice);
	printf("test 2 \n");
	
	cudaBindTexture(0,texFulltable,d_fullTable ,65536*32);
	cudaBindTexture(NULL,texacsm,acsm,sizeof(acsm));
	printf("test 3 \n");
	//free(fullTable);
  
  ////////////////////////////////////////////////////////////////////////
  //acsm pattern
  vector<string> patNumstr;
  vector<string> patTERN;
  cout<<"Start to read Pattern file!"<<endl;
  
  //load pattern data
  inFile.open(PATTERN_FILE_PATH);
  while(getline(inFile,line))
  {
  	patTERN.push_back(line);
  }
  inFile.close();
  inFile.clear();
  cout<<"End read Pattern file!"<<endl;
  //end!

  //load pattern num data
  inFile.open(PAT_FILE_PATH);
  while(getline(inFile,line))
  {
  	patNumstr.push_back(line);
  }
  inFile.close();
  inFile.clear();
  cout<<"Done for load pattern!"<<endl;

  stable_sort(patNumstr.begin(),patNumstr.end(), sortRule);

  vector<int> patternNum[patNumstr.size()];
  for(int i=0; i<patNumstr.size();i++)
  {
  	for(int j=0;j<patNumstr[i].size();j=j+3)
	{
		patternNum[i].push_back(StrToInt(patNumstr[i].substr(j,3)));
	}
  }
  //end!
  
  //snort mwm
  ps = mwmNew();
  //snort ac
#define acsm_print printf ("MAX_Memory: %d bytes, acsmMacStates: %d, acsmNumStates: %d  mem: acsm: %d maxstate: %d numstate: %d pattern %d statetalbe %d\n", max_memory, acsm->acsmMaxStates, acsm->acsmNumStates, &acsm, &(acsm->acsmMaxStates), &(acsm->acsmNumStates), &(acsm->acsmPatterns), &(acsm-<acsmStateTable));

  //acsmNew()
  printf("cudaMallocManaged\n");
  r = cudaMallocManaged(&(acsm), sizeof(ACSM_STRUCT));
  //err acsm_print printf("acsm NER\n");
  init_xlatcase();
  
  memset(acsm, 0, sizeof(ACSM_STRUCT));
  //end!

  //add pattern
  cout<<"add pattern"<<endl;
  for(int x=0; x<patNumstr.size();x++)
  {
  	char* s_mwm = (char*) malloc (sizeof(char)*(patternNum[x].size()+1));

	for(int y=0; y<patternNum[x].size();y++)
	{
		s_mwm[y] = (unsigned char)patternNum[x][y];
	}

	mwmAddPatternEx(ps, (unsigned char*)s_mwm, patternNum[x].size(), nocase, 0, 0, (void*)npats, 3000);
	acsmAddPattern(acsm, (unsigned char*)s_mwm, patternNum[x].size(), nocase, 0, 0, s_mwm, x+1);

	#ifdef _test
	patArray[npats] = s_mwm;
	#endif
	npats++;
  }
  mwmPrepPatterns(ps);
  
  cout<<"patNumstr.size() :"<<patNumstr.size()<<endl;
  //end!


  //acsmCompile()
  cout<<"acsmCompile"<<endl;
  acsmCompile(acsm);
  cout << "sizeofACSM_statetable: " << sizeof(ACSM_STATETABLE);
  cout << "sizeofACSM_pattern: " << sizeof(ACSM_PATTERN);
  cout << "sizeofACSM_struct: " << sizeof(ACSM_STRUCT);

  //outputtest2019/05/21
  /*int testvt1pos = 46*256+115;
  unsigned long long int testpop=0;
  int testcheckbt=0;
  int testpidfort2=0;
  cout << T1b_bool[46*256+115] << endl;
  cout << T2_bool[78*256+104] << endl;
  testpop = BitArrayToInt(T1b_bool,(testvt1pos/64)*64,testvt1pos);
  cout << "testpop: " << testpop << endl;
  cout << "BitArrayToTint(T1b_bool,(" << (testvt1pos/64)*64 << "," << testvt1pos << ")" << endl;
  testcheckbt = (int)BT[testvt1pos/64];
  cout << "(int)BT[" << testvt1pos/64 << "]" << endl;
  for(int i=11840;i<=11891;i++)
  {
  	cout << "T1b_bool[" << i << "]= " << T1b_bool[i] << endl;
  }
  testpidfort2 = testcheckbt + popcount_3(testpop);
  cout << testpidfort2 << "= " << testcheckbt << " + " << "popcount_3(" << testpop << ") " << popcount_3(testpop) << "." << endl;
  cout << T2_bool[testpidfort2*256+104] << endl;*/
  //end! /////////////////////////////////////////////////////////////////
  zc = pfring_zc_create_cluster(
    cluster_id, 
    max_packet_len(device1), 
    0, 
    ((2 * MAX_CARD_SLOTS) + 1) * (1 + bidirectional),
    NULL, //pfring_zc_numa_get_cpu_node(dir[0].bind_core)
    NULL /* auto hugetlb mountpoint */ 
  );

  if(zc == NULL) {
    fprintf(stderr, "pfring_zc_create_cluster error [%s] Please check your hugetlb configuration\n",
	    strerror(errno));
    return -1;
  }
	
	if(two_NIC == 0) //only use one NIC and one thread
	{
		for(int i = 0; i < num_threads; i++)
		{
			ss << i;
			ss >> idder;
			string temp1 = string(device1) + string(device_at) + idder; //ens4f1 + @ + i
			string temp2 = string(device2) + string(device_at) + idder; //ens4f0 + @ + i
			device1_rss[i]=strdup(temp1.c_str());
			device2_rss[i]=strdup(temp2.c_str());
			/*if (init_direction(&dir[0], device1, device2) < 0) 
				return -1;*/
			if (init_direction(&dir[i], device1_rss[i], device2_rss[i]) < 0)
			{
				return -1;
			}
			ss.clear();	
		}
	}else if(two_NIC > 0) //use both two NIC and 2*threads
	{
		for(int i = 0; i < num_threads/2; i++)
		{
			cout<<"i: "<<i<<endl;
			ss << i;
			ss >> idder;
			string temp1 = string(device1) + string(device_at) + idder;       //zc:ens4f1 + @ + i
			string temp2 = string(device2) + string(device_at) + idder;       //zc:ens4f0 + @ + i
			string temp3 = string(device_10_in) + string(device_at) + idder;  //zc:ens10f1 + @ + i
			string temp4 = string(device_10_out) + string(device_at) + idder; //zc:ens10f0 + @ + i
			
			device1_rss[i] = strdup(temp1.c_str());        //zc:ens4f1@i
			device2_rss[i] = strdup(temp2.c_str());        //zc:ens4f0@i
			device1_rss_NIC[i] = strdup(temp3.c_str());  //zc:ens10f1@i
			device2_rss_NIC[i] = strdup(temp4.c_str());  //zc:ens10f0@i
			/*if (init_direction(&dir[0], device1, device2) < 0) 
				return -1;*/
			if (init_direction(&dir[2*i], device1_rss[i], device2_rss[i]) < 0)
			{
				return -1;
			}
			if (init_direction(&dir[(2*i)+1], device1_rss_NIC[i], device2_rss_NIC[i]) < 0)
			{
				return -1;
			}
			ss.clear();	
		}
	}
  
	if (bidirectional)
	{
		if (init_direction(&dir[1], device2, device1) < 0) 
		{
			return -1;
		}
	}
	
  	//signal(SIGINT, sigproc);
	//signal(SIGTERM, sigproc);
	//signal(SIGINT, sigproc);
  	
	cout << "The ZX cluster [id: " << cluster_id << "][num consumer threads: " << num_threads << "] is running..." <<endl;
	for(int i = 0; i < num_threads; i++)
	{
		if (two_NIC==0)
		{
			cout<<"Thread"<<i<<": ";
			cout<<"In_device: "<<device1<<"@"<<i<<"  ;  Out_device: "<<device2<<"@"<<i<<endl;
		}else if (two_NIC > 0)
		{
			cout<<"Thread"<<i<<": ";
			cout<<"In_device: "<<device1<<"@"<<i<<", "<<device_10_in<<"@"<<i<<" ; ";
			cout<<"Out_device: "<<device2<<"@"<<i<<", "<<device_10_out<<"@"<<i<<endl;
		}
		/*pthread_create(&dir[0].thread, NULL, packet_consumer_thread, (void *) &dir[0]);
		if (bidirectional) pthread_create(&dir[1].thread, NULL, packet_consumer_thread, (void *) &dir[1]);*/
		pthread_create(&dir[i].thread, NULL, packet_consumer_thread, (void *) &dir[i]);
	}
	
	//output+again
    	signal(SIGINT,  sigproc);
	signal(SIGTERM, sigproc);
	signal(SIGINT,  sigproc);

  if (!verbose) while (!do_shutdown) {
    sleep(ALARM_SLEEP);
    print_stats();
  }
  //no again
  //signal(SIGINT, sigproc);
	
	for(int i = 0; i < num_threads; i++)
	{
		/*pthread_join(dir[0].thread, NULL);
		if (bidirectional) pthread_join(dir[1].thread, NULL);*/
		pthread_join(dir[i].thread, NULL);
	}
	cout<<"hello?"<<endl;
	outputyo.close();
//#ifdef _test
	gpuoutput.close();
//#endif
  sleep(1);

  pfring_zc_destroy_cluster(zc);
	sem_destroy(&os_sem);
  return 0;
}

